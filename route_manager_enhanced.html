<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rota Yönetimi - Gelişmiş Panel</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --route-primary: #2563eb;
            --route-secondary: #64748b;
            --route-success: #059669;
            --route-danger: #dc2626;
            --route-warning: #d97706;
            --route-info: #0891b2;
            --route-light: #f8fafc;
            --route-dark: #0f172a;
            --route-border: #e2e8f0;
            --route-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --route-shadow-hover: 0 8px 25px rgba(0, 0, 0, 0.15);
            --route-radius: 12px;
            --route-radius-lg: 16px;
            --route-transition: all 0.3s ease;
        }

        body {
            background: var(--route-light);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Main Layout */
        .route-management-container {
            display: grid;
            grid-template-areas:
                "header header header"
                "sidebar workspace map";
            grid-template-columns: 380px 1fr 600px;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 1rem;
            padding: 1rem;
            position: relative;
        }

        /* Resizable Splitter */
        .resize-handle {
            position: absolute;
            top: 80px;
            /* Header yüksekliği + padding */
            right: 620px;
            /* Map genişliği + gap */
            width: 8px;
            height: calc(100vh - 100px);
            background: linear-gradient(90deg, transparent 2px, var(--route-border) 2px, var(--route-border) 6px, transparent 6px);
            cursor: col-resize;
            z-index: 1000;
            transition: all 0.2s ease;
            border-radius: 4px;
        }

        .resize-handle:hover {
            background: linear-gradient(90deg, transparent 1px, var(--route-primary) 1px, var(--route-primary) 7px, transparent 7px);
            box-shadow: 0 0 8px rgba(37, 99, 235, 0.3);
        }

        .resize-handle.dragging {
            background: linear-gradient(90deg, transparent 1px, var(--route-primary) 1px, var(--route-primary) 7px, transparent 7px);
            box-shadow: 0 0 12px rgba(37, 99, 235, 0.5);
        }

        .resize-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 30px;
            background: repeating-linear-gradient(to bottom,
                    var(--route-secondary) 0px,
                    var(--route-secondary) 3px,
                    transparent 3px,
                    transparent 6px);
            opacity: 0.5;
            transition: opacity 0.2s ease;
        }

        .resize-handle:hover::before,
        .resize-handle.dragging::before {
            opacity: 1;
        }

        /* Header */
        .route-header {
            grid-area: header;
            background: white;
            border-radius: var(--route-radius-lg);
            box-shadow: var(--route-shadow);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .route-header h1 {
            margin: 0;
            color: var(--route-dark);
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .main-navigation {
            display: flex;
            gap: 1rem;
        }

        .main-navigation a {
            padding: 0.5rem 1rem;
            border-radius: 25px;
            text-decoration: none;
            color: var(--route-secondary);
            font-weight: 500;
            transition: var(--route-transition);
            border: 2px solid transparent;
        }

        .main-navigation a.active {
            background: var(--route-primary);
            color: white;
            box-shadow: var(--route-shadow);
        }

        .main-navigation a:hover:not(.active) {
            background: var(--route-light);
            border-color: var(--route-border);
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .btn-primary {
            background: var(--route-primary);
            border: none;
            border-radius: 25px;
            padding: 0.5rem 1.25rem;
            font-weight: 600;
            transition: var(--route-transition);
        }

        .btn-primary:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
            box-shadow: var(--route-shadow-hover);
        }

        /* Sidebar */
        .route-sidebar {
            grid-area: sidebar;
            background: white;
            border-radius: var(--route-radius-lg);
            box-shadow: var(--route-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            background: linear-gradient(135deg, var(--route-primary) 0%, #1e40af 100%);
            color: white;
            padding: 1.5rem;
            text-align: center;
        }

        .sidebar-header h3 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .sidebar-controls {
            padding: 1rem;
            border-bottom: 1px solid var(--route-border);
            background: var(--route-light);
        }

        .search-container {
            position: relative;
            margin-bottom: 1rem;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            border: 2px solid var(--route-border);
            border-radius: 25px;
            font-size: 0.9rem;
            transition: var(--route-transition);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--route-primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--route-secondary);
        }

        .filter-controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--route-dark);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-select {
            padding: 0.5rem;
            border: 2px solid var(--route-border);
            border-radius: var(--route-radius);
            font-size: 0.85rem;
            transition: var(--route-transition);
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--route-primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .bulk-actions {
            padding: 1rem;
            border-bottom: 1px solid var(--route-border);
            background: #fef3c7;
            display: none;
        }

        .bulk-actions.show {
            display: block;
        }

        .bulk-actions-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .bulk-count {
            font-weight: 600;
            color: var(--route-warning);
        }

        .bulk-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .btn-bulk {
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.8rem;
            border: none;
            cursor: pointer;
            transition: var(--route-transition);
        }

        .btn-bulk-export {
            background: var(--route-info);
            color: white;
        }

        .btn-bulk-delete {
            background: var(--route-danger);
            color: white;
        }

        .btn-bulk-edit {
            background: var(--route-warning);
            color: white;
        }

        /* Route List */
        .route-list-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .route-list-container::-webkit-scrollbar {
            width: 6px;
        }

        .route-list-container::-webkit-scrollbar-track {
            background: var(--route-light);
            border-radius: 3px;
        }

        .route-list-container::-webkit-scrollbar-thumb {
            background: var(--route-border);
            border-radius: 3px;
        }

        .route-list-container::-webkit-scrollbar-thumb:hover {
            background: var(--route-secondary);
        }

        .route-item {
            background: white;
            border: 2px solid var(--route-border);
            border-radius: var(--route-radius);
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: var(--route-transition);
            position: relative;
        }

        .route-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--route-primary);
            transform: scaleY(0);
            transition: transform 0.3s ease;
            border-radius: 2px 0 0 2px;
        }

        .route-item:hover {
            border-color: var(--route-primary);
            transform: translateY(-2px);
            box-shadow: var(--route-shadow-hover);
        }

        .route-item:hover::before {
            transform: scaleY(1);
        }

        .route-item.selected {
            border-color: var(--route-primary);
            background: rgba(37, 99, 235, 0.05);
            box-shadow: var(--route-shadow-hover);
        }

        .route-item.selected::before {
            transform: scaleY(1);
        }

        .route-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .route-item-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-route-info {
            background: none;
            border: none;
            color: var(--route-primary);
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: var(--route-transition);
            opacity: 0.7;
        }

        .btn-route-info:hover {
            background: rgba(37, 99, 235, 0.1);
            opacity: 1;
            transform: scale(1.1);
        }

        .route-checkbox {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .route-item-title {
            font-weight: 700;
            color: var(--route-dark);
            margin: 0;
            font-size: 1rem;
            line-height: 1.3;
            padding-right: 2rem;
        }

        .route-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .route-type-walking {
            background: #dcfce7;
            color: #166534;
        }

        .route-type-hiking {
            background: #fef3c7;
            color: #92400e;
        }

        .route-type-cycling {
            background: #dbeafe;
            color: #1e40af;
        }

        .route-type-driving {
            background: #fce7f3;
            color: #be185d;
        }

        .route-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .route-stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--route-secondary);
        }

        .route-stat-icon {
            width: 16px;
            text-align: center;
            color: var(--route-primary);
        }

        .difficulty-stars {
            color: #fbbf24;
            font-size: 0.9rem;
        }

        .route-description {
            font-size: 0.85rem;
            color: var(--route-secondary);
            line-height: 1.4;
            margin-bottom: 0.75rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        /* Workspace */
        .route-workspace {
            grid-area: workspace;
            background: white;
            border-radius: var(--route-radius-lg);
            box-shadow: var(--route-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .workspace-header {
            background: linear-gradient(135deg, var(--route-secondary) 0%, #475569 100%);
            color: white;
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .workspace-title {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .workspace-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn-workspace {
            padding: 0.5rem 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: var(--route-transition);
        }

        .btn-workspace:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .btn-workspace.btn-danger {
            border-color: rgba(220, 38, 38, 0.5);
            color: #dc2626;
        }

        .btn-workspace.btn-danger:hover {
            background: rgba(220, 38, 38, 0.1);
            border-color: #dc2626;
        }

        .workspace-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .empty-workspace {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--route-secondary);
            text-align: center;
        }

        .empty-workspace i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Map View */
        .route-map-view {
            grid-area: map;
            background: white;
            border-radius: var(--route-radius-lg);
            box-shadow: var(--route-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .map-header {
            background: linear-gradient(135deg, var(--route-success) 0%, #047857 100%);
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .map-title {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .map-controls {
            display: flex;
            gap: 0.5rem;
        }

        .btn-map {
            padding: 0.25rem 0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            border-radius: 15px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--route-transition);
        }

        .btn-map:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #routeMap {
            flex: 1;
            min-height: 400px;
            position: relative;
        }

        #routeMap.select-location {
            cursor: crosshair;
        }

        #routeMap.select-location::after {
            content: 'Fotoğraf konumu için haritaya tıklayın';
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1000;
        }

        .route-media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }

        .route-media-card {
            background: white;
            border: 2px solid var(--route-border);
            border-radius: var(--route-radius);
            overflow: hidden;
            position: relative;
            transition: var(--route-transition);
        }

        .route-media-card:hover {
            border-color: var(--route-primary);
            box-shadow: var(--route-shadow-hover);
            transform: translateY(-2px);
        }

        .route-media-thumb {
            width: 100%;
            height: 100px;
            object-fit: cover;
        }

        .route-media-delete {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .route-media-panel {
            background: white;
            border-radius: var(--route-radius);
            border: 2px solid var(--route-border);
            padding: 1rem;
            max-height: 100%;
            overflow-y: auto;
        }

        /* Elevation Chart Container */
        .route-elevation-container {
            background: white;
            border-top: 1px solid var(--route-border);
            padding: 1rem;
        }

        /* Map Fullscreen */
        .route-map-view.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            border-radius: 0;
        }

        body.map-fullscreen {
            overflow: hidden;
        }

        .route-map-view.fullscreen #routeMap {
            min-height: calc(100vh - 60px);
            /* Header yüksekliği çıkarılmış */
        }

        /* Custom POI Map Markers */
        .custom-poi-marker {
            background: transparent !important;
            border: none !important;
        }

        .poi-marker-container {
            width: 35px;
            height: 35px;
            border-radius: 50% 50% 50% 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
            border: 3px solid white;
            transition: transform 0.2s ease;
            position: relative;
            transform: rotate(-45deg);
        }

        .poi-marker-container i {
            transform: rotate(45deg);
            z-index: 2;
        }

        .poi-order-number {
            position: absolute;
            bottom: -8px;
            right: -8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            transform: rotate(45deg);
            border: 2px solid white;
        }

        .poi-marker-container:hover {
            transform: rotate(-45deg) scale(1.1);
            z-index: 1000;
        }

        /* Media location markers */
        .media-marker {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            border: 2px solid white;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            font-size: 12px;
        }

        .media-marker.image {
            background: #f59e0b;
        }

        .media-marker.video {
            background: #ef4444;
        }

        .media-marker.audio {
            background: #10b981;
        }

        .media-marker.model_3d {
            background: #6366f1;
        }

        /* POI Popup Styles */
        .poi-popup {
            min-width: 200px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .poi-popup-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
        }

        .poi-popup-category {
            color: #666;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            font-style: italic;
        }
        .poi-popup-description {
            color: #444;
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }
        .poi-popup-order {
            color: #666;
            font-size: 0.8rem;
            font-weight: 600;
        }

        /* Photo Location Management Styles */
        .photo-location-management {
            background: #f8f9fa;
            border: 1px solid var(--route-border);
            border-radius: var(--route-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .photo-location-management .alert {
            margin-bottom: 1rem;
        }

        .photo-location-management .alert h6 {
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .photo-location-management .alert ul {
            margin-bottom: 0;
            padding-left: 1.25rem;
        }

        .photo-location-management .alert li {
            margin-bottom: 0.25rem;
        }

        .photo-location-info {
            margin-bottom: 1rem;
        }

        .photo-location-info p {
            margin: 0;
            font-size: 0.9rem;
        }

        .photo-location-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .photo-location-controls .btn {
            font-size: 0.8rem;
            padding: 0.375rem 0.75rem;
        }

        /* Media Item Location Styles */
        .media-item-card.has-location {
            border-color: var(--route-success);
            box-shadow: 0 0 0 1px var(--route-success);
        }

        .media-location-info {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--route-border);
        }

        .location-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .location-badge.location-set {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .location-badge.location-missing {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .location-actions {
            display: flex;
            gap: 0.25rem;
            margin-left: auto;
        }

        .location-source-info {
            margin-top: 0.5rem;
            text-align: center;
        }

        .location-source-info small {
            display: block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .location-source-info .text-success {
            background: rgba(5, 150, 105, 0.1);
            border: 1px solid rgba(5, 150, 105, 0.2);
        }

        .location-source-info .text-muted {
            background: rgba(100, 116, 139, 0.1);
            border: 1px solid rgba(100, 116, 139, 0.2);
        }

        .btn-location-edit,
        .btn-location-add,
        .btn-location-remove {
            background: none;
            border: none;
            padding: 0.125rem 0.25rem;
            border-radius: 4px;
            cursor: pointer;
            transition: var(--route-transition);
            opacity: 0.7;
        }

        .btn-location-edit:hover,
        .btn-location-add:hover,
        .btn-location-remove:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.1);
        }

        .btn-location-edit {
            color: var(--route-primary);
        }

        .btn-location-add {
            color: var(--route-success);
        }

        .btn-location-remove {
            color: var(--route-danger);
        }

        .webp-conversion-actions {
            margin-top: 0.5rem;
        }

        .webp-conversion-actions .btn {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .webp-conversion-actions .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .debug-actions {
            margin-top: 0.25rem;
        }

        .debug-actions .btn {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .debug-actions .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        /* Map Location Selection Styles */
        #routeMap.select-location {
            cursor: crosshair;
        }

        #routeMap.select-location::after {
            content: 'Fotoğraf konumu için haritaya tıklayın';
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
        }

        /* Route Details Popup Styles */
        .route-detail-popup {
            padding: 0;
        }

        .route-detail-popup .route-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--route-border);
        }

        .route-detail-popup .route-description-full {
            margin-bottom: 1.5rem;
        }

        .route-detail-popup .route-description-full h6 {
            color: var(--route-primary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .route-detail-popup .route-statistics h6 {
            color: var(--route-primary);
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .stats-grid-popup {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .stat-card-popup {
            display: flex;
            align-items: center;
            padding: 1rem;
            background: var(--route-light);
            border-radius: var(--route-radius);
            border: 1px solid var(--route-border);
        }

        .stat-card-popup .stat-icon {
            margin-right: 0.75rem;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--route-primary);
            color: white;
            border-radius: 50%;
            font-size: 1rem;
        }

        .stat-card-popup .stat-info {
            flex: 1;
        }

        .stat-card-popup .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--route-primary);
            line-height: 1;
        }

        .stat-card-popup .stat-label {
            font-size: 0.8rem;
            color: var(--route-secondary);
            margin-top: 0.25rem;
        }

        .route-detail-popup .route-tags-section h6 {
            color: var(--route-primary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .route-detail-popup .route-metadata h6 {
            color: var(--route-primary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .metadata-grid-popup {
            display: grid;
            gap: 0.5rem;
        }

        .metadata-grid-popup .metadata-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--route-border);
        }

        .metadata-grid-popup .metadata-item:last-child {
            border-bottom: none;
        }

        /* POI Order Badge */
        .poi-order-badge {
            display: inline-block;
            background: var(--route-primary);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-right: 0.5rem;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .route-management-container {
                grid-template-areas:
                    "header header"
                    "sidebar workspace"
                    "map map";
                grid-template-columns: 350px 1fr;
                grid-template-rows: auto 1fr 450px;
            }

            .resize-handle {
                display: none;
                /* Hide splitter on smaller screens */
            }
        }

        @media (max-width: 768px) {
            .route-management-container {
                grid-template-areas:
                    "header"
                    "sidebar"
                    "workspace"
                    "map";
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr 300px;
                padding: 0.5rem;
                gap: 0.5rem;
            }

            .route-header {
                padding: 1rem;
            }

            .route-header h1 {
                font-size: 1.2rem;
            }

            .main-navigation {
                flex-direction: column;
                gap: 0.5rem;
            }

            .header-actions {
                flex-direction: column;
                gap: 0.5rem;
            }
        }

        /* Loading States */
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--route-border);
            border-top: 4px solid var(--route-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            min-width: 300px;
            padding: 1rem;
            border-radius: var(--route-radius);
            box-shadow: var(--route-shadow-hover);
            animation: slideIn 0.3s ease;
        }

        .notification-success {
            background: var(--route-success);
            color: white;
        }

        .notification-error {
            background: var(--route-danger);
            color: white;
        }

        .notification-info {
            background: var(--route-info);
            color: white;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="route-management-container" id="routeContainer">
        <!-- Resizable Splitter -->
        <div class="resize-handle" id="resizeHandle"></div>

        <!-- Header -->
        <header class="route-header">
            <h1>
                <i class="fas fa-route"></i>
                Rota Yönetimi
            </h1>
            <nav class="main-navigation">
                <a href="poi_manager_enhanced.html">
                    <i class="fas fa-map-marker-alt me-1"></i>
                    POI Yönetimi
                </a>
                <a href="route_manager_enhanced.html" class="active">
                    <i class="fas fa-route me-1"></i>
                    Rota Yönetimi
                </a>
                <a href="file_import_manager.html">
                    <i class="fas fa-file-import me-1"></i>
                    Dosya Import
                </a>
            </nav>
            <div class="header-actions">
                <button class="btn btn-primary" onclick="createAndEditRoute()">
                    <i class="fas fa-plus me-1"></i>
                    Yeni Rota
                </button>
                <button class="btn btn-outline-secondary" onclick="refreshRoutes()">
                    <i class="fas fa-sync-alt me-1"></i>
                    Yenile
                </button>
                <button class="btn btn-outline-warning" onclick="clearMapRoutes()"
                    title="Haritadaki tüm rotaları temizle">
                    <i class="fas fa-eraser me-1"></i>
                    Haritayı Temizle
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="route-sidebar">
            <div class="sidebar-header">
                <h3>
                    <i class="fas fa-list me-2"></i>
                    Rota Listesi
                </h3>
            </div>

            <!-- Search and Filters -->
            <div class="sidebar-controls">
                <div class="search-container">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" class="search-input" id="routeSearch" placeholder="Rota ara..."
                        oninput="handleSearch()">
                </div>

                <div class="filter-controls">
                    <div class="filter-group">
                        <label class="filter-label">
                            <i class="fas fa-filter"></i>
                            Rota Türü
                        </label>
                        <select class="filter-select" id="typeFilter" onchange="applyFilters()">
                            <option value="">Tüm Türler</option>
                            <option value="walking">🚶 Yürüyüş</option>
                            <option value="hiking">🥾 Doğa Yürüyüşü</option>
                            <option value="cycling">🚴 Bisiklet</option>
                            <option value="driving">🚗 Araba</option>
                        </select>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">
                            <i class="fas fa-star"></i>
                            Zorluk Seviyesi
                        </label>
                        <select class="filter-select" id="difficultyFilter" onchange="applyFilters()">
                            <option value="">Tüm Seviyeler</option>
                            <option value="1">⭐ Çok Kolay</option>
                            <option value="2">⭐⭐ Kolay</option>
                            <option value="3">⭐⭐⭐ Orta</option>
                            <option value="4">⭐⭐⭐⭐ Zor</option>
                            <option value="5">⭐⭐⭐⭐⭐ Çok Zor</option>
                        </select>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">
                            <i class="fas fa-clock"></i>
                            Maksimum Süre
                        </label>
                        <select class="filter-select" id="durationFilter" onchange="applyFilters()">
                            <option value="">Süre Sınırı Yok</option>
                            <option value="30">30 dakika</option>
                            <option value="60">1 saat</option>
                            <option value="120">2 saat</option>
                            <option value="240">4 saat</option>
                            <option value="480">8 saat</option>
                        </select>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">
                            <i class="fas fa-sort"></i>
                            Sıralama
                        </label>
                        <select class="filter-select" id="sortFilter" onchange="applyFilters()">
                            <option value="name_asc">İsim (A-Z)</option>
                            <option value="name_desc">İsim (Z-A)</option>
                            <option value="created_desc">En Yeni</option>
                            <option value="created_asc">En Eski</option>
                            <option value="difficulty_asc">Kolay → Zor</option>
                            <option value="difficulty_desc">Zor → Kolay</option>
                            <option value="duration_asc">Kısa → Uzun</option>
                            <option value="duration_desc">Uzun → Kısa</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Bulk Actions -->
            <div class="bulk-actions" id="bulkActions">
                <div class="bulk-actions-header">
                    <span class="bulk-count" id="bulkCount">0 rota seçildi</span>
                    <button class="btn-bulk btn-bulk-clear" onclick="clearSelection()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="bulk-buttons">
                    <button class="btn-bulk btn-bulk-export" onclick="exportSelected()">
                        <i class="fas fa-download me-1"></i>
                        Dışa Aktar
                    </button>
                    <button class="btn-bulk btn-bulk-edit" onclick="bulkEdit()">
                        <i class="fas fa-edit me-1"></i>
                        Toplu Düzenle
                    </button>
                    <button class="btn-bulk btn-bulk-delete" onclick="deleteSelected()">
                        <i class="fas fa-trash me-1"></i>
                        Sil
                    </button>
                </div>
            </div>

            <!-- Route List -->
            <div class="route-list-container" id="routeListContainer">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </aside>

        <!-- Workspace -->
        <main class="route-workspace">
            <div class="workspace-header">
                <h3 class="workspace-title" id="workspaceTitle">Rota Detayları</h3>
                <div class="workspace-actions" id="workspaceActions" style="display: none;">
                    <button class="btn-workspace" onclick="editCurrentRoute()">
                        <i class="fas fa-edit me-1"></i>
                        Düzenle
                    </button>
                    <button class="btn-workspace" onclick="duplicateCurrentRoute()">
                        <i class="fas fa-copy me-1"></i>
                        Kopyala
                    </button>
                    <button class="btn-workspace" onclick="exportCurrentRoute()">
                        <i class="fas fa-download me-1"></i>
                        Dışa Aktar
                    </button>
                    <button class="btn-workspace btn-danger" onclick="deleteCurrentRoute()">
                        <i class="fas fa-trash me-1"></i>
                        Sil
                    </button>
                    <button class="btn-workspace" onclick="clearRouteSelection()" title="Rota seçimini temizle">
                        <i class="fas fa-times me-1"></i>
                        Seçimi Temizle
                    </button>
                </div>
            </div>
            <div class="workspace-content" id="workspaceContent">
                <div class="empty-workspace">
                    <i class="fas fa-route"></i>
                    <h4>Rota Seçin</h4>
                    <p>Detayları görüntülemek için sol taraftan bir rota seçin</p>
                </div>
            </div>
        </main>

        <!-- Map View -->
        <section class="route-map-view">
            <div class="map-header">
                <h3 class="map-title" id="mapTitle">
                    <i class="fas fa-map me-2"></i>
                    Harita Görünümü
                </h3>
                <div class="map-controls">
                    <button class="btn-map" onclick="toggleMapLayer('satellite')" title="Uydu Görünümü">
                        <i class="fas fa-satellite"></i>
                    </button>
                    <button class="btn-map" onclick="toggleMapLayer('terrain')" title="Arazi Görünümü">
                        <i class="fas fa-mountain"></i>
                    </button>
                    <button class="btn-map" onclick="fitMapToRoutes()" title="Rotalara Odaklan">
                        <i class="fas fa-expand-arrows-alt"></i>
                    </button>
                    <button class="btn-map" onclick="toggleMapFullscreen()" title="Tam Ekran" id="fullscreenBtn">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div>
            <div id="routeMap" tabindex="-1"></div>
            <!-- Elevation Chart Container -->
            <div class="route-elevation-container">
                <div id="routeElevationChartContainer" class="elevation-chart-hidden"></div>
            </div>
        </section>
    </div>



    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="static/js/map-layer-control.js"></script>
    <script src="static/js/rate-limiter.js"></script>
    <script src="static/js/elevation-chart.js"></script>
    <script src="static/js/api-client.js"></script>
    <script src="static/js/navigation-manager.js"></script>
    <script src="static/js/route-admin-manager.js"></script>
    <script>
        // Yönetim arayüzü için RouteAdminManager'ı başlat
        if (window.RouteAdminManager) {
            window.routeAdminManager = new RouteAdminManager('routeContainer');

            // Eski kod ile uyumluluk için loadRouteMedia fonksiyonunu yayınla
            window.loadRouteMedia = (routeId) =>
                window.routeAdminManager.loadRouteMedia(routeId);
        }

        // Rate limiting bilgilendirme mesajı
        if (window.rateLimiter) {
            console.log('✅ Rate limiting aktif - API çağrıları sınırlandırılacak');
        }

        // Tüm rotaları haritadan kaldır
        function clearAllRoutesFromMap() {
            Object.values(routeLayers).forEach(layer => {
                try {
                    map.removeLayer(layer);
                } catch (e) {
                    console.warn('Layer removal error:', e);
                }
            });
            routeLayers = {};
            console.log('Tüm rotalar haritadan kaldırıldı');

            if (window.routeElevationChart) {
                window.routeElevationChart.hideChart();
            }
        }

        // POI'lerden dinamik rota oluştur
        async function createRouteFromPOIs(route, color) {
            const rid = getRouteId(route);
            console.log('POI\'lerden rota oluşturuluyor:', route.name);

            try {
                // Rota detaylarını al (elevation_profile için)
                let routeDetails = route;
                if (!route.elevation_profile) {
                    try {
                        const detailResp = await rateLimitedFetch(`${apiBase}/admin/routes/${rid}`, {
                            credentials: 'include'
                        });
                        if (detailResp.ok) {
                            routeDetails = await detailResp.json();
                        }
                    } catch (detailErr) {
                        console.warn('Rota detayları alınamadı:', detailErr);
                    }
                }

                // Rotanın POI'lerini al
                const response = await rateLimitedFetch(`${apiBase}/admin/routes/${rid}/pois`, {
                    credentials: 'include'
                });

                if (response.ok) {
                    const data = await response.json();
                    const pois = data.pois || data.results || [];

                    if (pois.length > 0) {
                        // POI koordinatlarını al
                        const latlngs = pois
                            .filter(poi => poi.latitude && poi.longitude)
                            .map(poi => [parseFloat(poi.latitude), parseFloat(poi.longitude)]);

                        if (latlngs.length > 1) {
                            // POI'ler arasında rota çiz
                            const layer = L.polyline(latlngs, {
                                color: color,
                                weight: 4,
                                opacity: 0.8,
                                dashArray: '8,4' // POI-based rotayı ayırt etmek için
                            }).addTo(map);

                            routeLayers[rid] = layer;

                            // POI marker'larını da ekle
                            pois.forEach((poi, index) => {
                                if (poi.latitude && poi.longitude) {
                                    const marker = L.marker([parseFloat(poi.latitude), parseFloat(poi.longitude)])
                                        .bindPopup(`
                                            <strong>${poi.name || 'POI'}</strong><br>
                                            <small>Sıra: ${index + 1}</small>
                                        `);
                                    poiMarkersLayer.addLayer(marker);
                                }
                            });

                            // Haritayı rotaya odakla
                            map.fitBounds(layer.getBounds(), { padding: [50, 50] });

                            console.log('✅ POI-based rota oluşturuldu:', pois.length, 'POI');
                            showNotification(`${pois.length} POI ile dinamik rota oluşturuldu`, 'success');

                            // Load elevation profile for POI-based route
                            if (window.routeElevationChart) {
                                if (routeDetails.elevation_profile && routeDetails.elevation_profile.points) {
                                    await window.routeElevationChart.loadElevationProfile(routeDetails.elevation_profile);

                                } else {
                                    await window.routeElevationChart.loadRouteElevation({
                                        pois: pois
                                            .filter(poi => poi.latitude && poi.longitude)
                                            .map(poi => ({
                                                name: poi.name,
                                                latitude: parseFloat(poi.latitude),
                                                longitude: parseFloat(poi.longitude)
                                            }))
                                    });
                                }

                            }
                        } else {
                            console.warn('Yeterli POI koordinatı yok');
                            showNotification('Bu rotada yeterli POI koordinatı bulunamadı', 'warning');
                        }
                    } else {
                        console.warn('Rota POI\'si bulunamadı');
                        showNotification('Bu rotaya ait POI bulunamadı', 'warning');
                    }
                } else {
                    console.warn('POI\'ler alınamadı:', response.status);
                }
            } catch (error) {
                console.error('POI-based rota oluşturma hatası:', error);
                showNotification('Dinamik rota oluşturulamadı', 'error');
            }
        }

        // Tek bir rotayı haritaya ekle
        async function showSingleRouteOnMap(route) {
            const rid = getRouteId(route);
            if (!rid) {
                console.warn('Route ID bulunamadı:', route);
                return;
            }

            try {
                // Rota detaylarını al (elevation_profile için)
                let routeDetails = route;
                if (!route.elevation_profile || !route.geometry) {
                    try {
                        const detailResp = await rateLimitedFetch(`${apiBase}/admin/routes/${rid}`, {
                            credentials: 'include'
                        });
                        if (detailResp.ok) {
                            routeDetails = await detailResp.json();
                        }
                    } catch (detailErr) {
                        console.warn('Rota detayları alınamadı:', detailErr);
                    }
                }

                // Önce mevcut geometriyi kontrol et
                let geometry = route.geometry || routeDetails.geometry;

                // Geometri yoksa veya string ise API'den al
                if (!geometry || typeof geometry === 'string') {
                    console.log(`Rota ${rid} için geometri API'den alınıyor...`);

                    try {
                        const response = await rateLimitedFetch(`${apiBase}/routes/${rid}/geometry`, {
                            credentials: 'include'
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.geometry) {
                                geometry = data.geometry;
                                console.log(`Geometri başarıyla alındı:`, geometry);
                            } else {
                                console.warn('API geometri döndürmedi:', data);
                            }
                        } else {
                            console.warn(`Geometri API hatası: ${response.status} ${response.statusText}`);
                        }
                    } catch (apiError) {
                        console.warn('Geometri API çağrısı başarısız:', apiError);
                    }
                }

                // Hibrit geometri işleme - hem statik hem dinamik rota desteği
                if (geometry) {
                    console.log('Ham geometri verisi:', geometry);

                    // String ise parse et
                    if (typeof geometry === 'string') {
                        try {
                            geometry = JSON.parse(geometry);
                        } catch (e) {
                            console.warn('Geometry JSON parse hatası:', e);
                            return;
                        }
                    }

                    // Rota rengini belirle
                    const color = ROUTE_TYPES[routeDetails.route_type]?.color || '#2563eb';
                    let layer = null;

                    // YAKLAŞIM 1: Statik LineString geometrisi (klasik)
                    if (geometry.type === 'LineString' && geometry.coordinates && geometry.coordinates.length > 0) {
                        console.log('📍 Statik LineString geometrisi kullanılıyor');
                        const latlngs = geometry.coordinates.map(coord => [coord[1], coord[0]]);
                        layer = L.polyline(latlngs, {
                            color: color,
                            weight: 4,
                            opacity: 0.8
                        });
                    }
                    // YAKLAŞIM 2: API response formatı (nested geometry)
                    else if (geometry.geometry && geometry.geometry.type === 'LineString') {
                        console.log('📍 Nested LineString geometrisi kullanılıyor');
                        const coords = geometry.geometry.coordinates;
                        if (coords && coords.length > 0) {
                            const latlngs = coords.map(coord => [coord[1], coord[0]]);
                            layer = L.polyline(latlngs, {
                                color: color,
                                weight: 4,
                                opacity: 0.8
                            });
                        }
                    }
                    // YAKLAŞIM 3: POI-based dinamik rota (waypoints)
                    else if (geometry.waypoints && Array.isArray(geometry.waypoints) && geometry.waypoints.length > 0) {
                        console.log('📍 POI-based waypoints kullanılıyor');
                        const latlngs = geometry.waypoints.map(wp => [wp.lat || wp.latitude, wp.lng || wp.longitude]);
                        if (latlngs.length > 1) {
                            // Waypoints arasında düz çizgi çek (basit yaklaşım)
                            layer = L.polyline(latlngs, {
                                color: color,
                                weight: 4,
                                opacity: 0.8,
                                dashArray: '5,5' // Dinamik rotayı ayırt etmek için kesikli çizgi
                            });
                        }
                    }
                    // YAKLAŞIM 4: Rota POI'lerinden dinamik rota oluştur
                    else {
                        console.log('📍 Rota POI\'lerinden dinamik rota oluşturuluyor');
                        await createRouteFromPOIs(routeDetails, color);
                        return; // createRouteFromPOIs kendi layer'ını oluşturacak
                    }

                    // Layer oluşturulduysa haritaya ekle
                    if (layer) {
                        layer.addTo(map);
                        routeLayers[rid] = layer;

                        // Haritayı rotaya odakla
                        map.fitBounds(layer.getBounds(), { padding: [50, 50] });

                        // Load elevation profile from route or available geometry data
                        if (window.routeElevationChart) {
                            if (routeDetails.elevation_profile && routeDetails.elevation_profile.points) {
                                await window.routeElevationChart.loadElevationProfile(routeDetails.elevation_profile);
                            } else if (geometry.type === 'LineString' && geometry.coordinates) {

                                await window.routeElevationChart.loadRouteElevation({
                                    geometry: geometry
                                });
                            } else if (geometry.geometry && geometry.geometry.type === 'LineString') {
                                await window.routeElevationChart.loadRouteElevation({
                                    geometry: geometry.geometry
                                });
                            } else if (geometry.waypoints && Array.isArray(geometry.waypoints) && geometry.waypoints.length > 0) {
                                await window.routeElevationChart.loadRouteElevation({
                                    pois: geometry.waypoints.map(wp => ({
                                        latitude: wp.lat || wp.latitude,
                                        longitude: wp.lng || wp.longitude,
                                        name: wp.name || ''
                                    }))
                                });
                            }

                            // Fetch route media with coordinates and overlay markers on map and elevation
                            try {
                                const mediaResp = await fetch(`${apiBase}/admin/routes/${rid}/media`, { credentials: 'include' });
                                if (mediaResp.ok) {
                                    const mediaJson = await mediaResp.json();
                                    const mediaItems = Array.isArray(mediaJson)
                                        ? mediaJson
                                        : (Array.isArray(mediaJson.media) ? mediaJson.media : []);

                                    // Ensure media types are set
                                    mediaItems.forEach(m => {
                                        if (!m.media_type) {
                                            const path = (m.filename || m.file_path || m.path || '').toLowerCase();
                                            if (path.match(/\.(webp|jpg|jpeg|png|gif|bmp|tiff)$/)) m.media_type = 'image';
                                            else if (path.match(/\.(mp4|avi|mov|wmv|flv|webm|mkv|m4v)$/)) m.media_type = 'video';
                                            else if (path.match(/\.(mp3|wav|ogg|m4a|aac|flac)$/)) m.media_type = 'audio';
                                            else if (path.match(/\.(glb|gltf|obj|fbx|dae|ply|stl)$/)) m.media_type = 'model_3d';
                                            else m.media_type = 'unknown';
                                        }
                                    });

                                    // Add markers for media that have coordinates
                                    const locatedMedia = mediaItems.filter(m => (m.lat || m.latitude) && (m.lng || m.longitude || m.lon));
                                    const typeLabels = { image: 'Fotoğraf', video: 'Video', audio: 'Ses', model_3d: '3D Model', unknown: 'Medya' };
                                    locatedMedia.forEach(m => {
                                        const lat = parseFloat(m.lat ?? m.latitude);
                                        const lng = parseFloat(m.lng ?? m.longitude ?? m.lon);
                                        if (isFinite(lat) && isFinite(lng)) {
                                            const label = typeLabels[m.media_type] || 'Medya';
                                            let preview = '';
                                            const mediaPath = m.preview_path || m.thumbnail_path || m.file_path;
                                            if (mediaPath) {
                                                if (m.media_type === 'image') {
                                                    preview = `<div style=\"margin-top:8px\"><img src='/${mediaPath}' alt='media' style='width:100%;border-radius:6px;'/></div>`;
                                                } else if (m.media_type === 'video') {
                                                    preview = `<div style=\"margin-top:8px\"><video src='/${mediaPath}' controls style='width:100%;border-radius:6px;max-height:200px'></video></div>`;
                                                } else if (m.media_type === 'audio') {
                                                    preview = `<div style=\"margin-top:8px\"><audio controls style='width:100%'><source src='/${mediaPath}'></audio></div>`;
                                                }
                                            }
                                            const mk = L.marker([lat, lng], { icon: getMediaMarkerIcon(m.media_type) })
                                                .bindPopup(`<div style=\"min-width:180px\"><strong>${label}</strong>${m.caption ? `<div style=\\\"margin-top:4px;color:#666\\\">${m.caption}</div>`: ''}${preview}</div>`)
                                                .addTo(map);
                                            poiMarkersLayer.addLayer(mk);
                                        }
                                    });

                                                        // Pass to elevation chart so markers appear on profile
                    if (window.routeElevationChart) {
                        window.routeElevationChart.setMediaMarkers(locatedMedia);
                    }
                    
                    // Store located media for elevation chart updates
                    if (window.routeElevationChart && locatedMedia.length > 0) {
                        window.routeElevationChart.setPhotoLocations(locatedMedia);
                    }
                                }
                            } catch (e) {
                                console.warn('Rota medyası yüklenemedi:', e);
                            }
                        }

                        console.log('✅ Rota haritaya eklendi:', routeDetails.name);

                    } else {
                        console.warn('Hiçbir geometri formatı işlenemedi:', geometry);
                        showNotification('Rota geometrisi işlenemedi', 'warning');
                    }
                } else {
                    console.warn('Rota geometrisi bulunamadı:', routeDetails.name);
                    showNotification('Bu rotanın geometrisi bulunamadı', 'warning');
                }
            } catch (error) {
                console.error('Rota yükleme hatası:', error);
                showNotification('Rota yüklenirken hata oluştu: ' + error.message, 'error');
            }
        }

        // Global variables
        const apiBase = '/api';
        let allRoutes = [];
        let filteredRoutes = [];
        let selectedRoutes = new Set();
        let currentRoute = null;
        let map = null;
        let routeLayers = {};
        let poiMarkersLayer = null;
        let searchTimeout = null;
        let associatedPoiIdSet = new Set();
        let associatedPoiOrderedIds = [];
        let allPoisForAssociation = [];
        let csrfToken = null;
        let defaultWorkspaceActionsHTML = '';

        // Rate limiting için
        let lastLoadTime = 0;
        const minLoadInterval = 2000; // 2 saniye minimum aralık
        let loadingInProgress = false;

        // --- Helpers: ID and parsing ---
        function getRouteId(route) {
            return route?.id ?? route?._id ?? route?.route_id ?? null;
        }

        function getPoiId(poi) {
            // Try different ID field names in order of preference
            return poi?.id ?? poi?._id ?? poi?.poi_id ?? null;
        }

        // Route type configurations
        const ROUTE_TYPES = {
            'walking': { name: 'Yürüyüş', icon: '🚶', color: '#059669' },
            'hiking': { name: 'Doğa Yürüyüşü', icon: '🥾', color: '#d97706' },
            'cycling': { name: 'Bisiklet', icon: '🚴', color: '#2563eb' },
            'driving': { name: 'Araba', icon: '🚗', color: '#dc2626' }
        };

        // POI Category configurations
        const POI_CATEGORIES = {
            'kulturel_miras': { name: '🏛️ Kültürel Miras', icon: 'landmark', color: '#8B4513' },
            'dogal_miras': { name: '🌿 Doğal Miras', icon: 'mountain', color: '#228B22' },
            'yasayan_kultur': { name: '🎨 Yaşayan Kültür', icon: 'palette', color: '#9932CC' },
            'gastronomi': { name: '🍽️ Gastronomi', icon: 'utensils', color: '#DC143C' },
            'konaklama_hizmet': { name: '🏨 Konaklama & Hizmetler', icon: 'bed', color: '#4169E1' },
            'macera_spor': { name: '🏃 Macera & Spor', icon: 'hiking', color: '#FF6347' },
            'seyir_noktalari': { name: '📷 Seyir Noktaları', icon: 'camera', color: '#ff9500' }
        };

        // Initialize application
        document.addEventListener('DOMContentLoaded', function () {
            initializeMap();
            loadRoutes();
            setupEventListeners();
            setupResizableMap();
            const workspaceActionsElem = document.getElementById('workspaceActions');
            defaultWorkspaceActionsHTML = workspaceActionsElem.innerHTML;
            // Fetch CSRF token for admin POSTs
            fetch('/auth/csrf-token', { credentials: 'include' })
                .then(r => r.ok ? r.json() : null)
                .then(d => { if (d?.csrf_token) csrfToken = d.csrf_token; })
                .catch(() => { });

            // Ensure media functionality is properly initialized
            console.log('Route manager initialized, media functionality ready');
            
            // Show info about automatic EXIF extraction
            setTimeout(() => {
                showNotification('📸 Otomatik EXIF konum çıkarma aktif! Fotoğraf yüklediğinizde GPS bilgisi otomatik olarak haritaya eklenir.', 'info');
            }, 2000);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function () {
            if (window.routeElevationChart) {
                window.routeElevationChart.destroy();
                window.routeElevationChart = null;
            }
        });

        // Fetch and attach geometry for routes if missing
        async function attachGeometriesToRoutes(routes) {
            try {
                const tasks = routes.map(async (r) => {
                    try {
                        const rid = getRouteId(r);
                        if (!rid || r.geometry) return;
                        const res = await fetch(`${apiBase}/routes/${rid}/geometry`, { credentials: 'include' });
                        if (!res.ok) {
                            if (res.status === 404) {
                                // Silently ignore 404s for routes without geometry
                                return;
                            }
                            console.warn(`Failed to fetch geometry for route ${rid}: ${res.status}`);
                            return;
                        }
                        const g = await res.json();
                        if (g && g.geometry) {
                            let geo = g.geometry;
                            if (typeof geo === 'string') {
                                try { geo = JSON.parse(geo); } catch (e) { /* ignore */ }
                            }
                            r.geometry = geo || r.geometry;
                            if (g.total_distance != null) r.total_distance = g.total_distance;
                            if (g.estimated_duration != null) r.estimated_duration = g.estimated_duration;
                        }
                    } catch (e) { /* ignore per route */ }
                });
                await Promise.all(tasks);
            } catch (e) {
                console.warn('attachGeometriesToRoutes failed:', e);
            }
        }

        // Initialize Leaflet map
        function initializeMap() {
            console.log('Initializing map...');
            const mapContainer = document.getElementById('routeMap');
            console.log('Map container:', mapContainer, 'Visible:', mapContainer ? mapContainer.offsetHeight : 'N/A');

            map = L.map('routeMap').setView([38.7312, 34.4547], 10);
            window.map = map;
            console.log('Map object created:', map);

            addBaseLayers(map);
            // Layer for POI markers of the selected route
            poiMarkersLayer = L.layerGroup().addTo(map);

            // Initialize elevation chart
            if (window.ElevationChart) {
                window.routeElevationChart = new ElevationChart('routeElevationChartContainer', map);
            }

            // Force map size invalidation after a short delay
            setTimeout(() => {
                if (map) {
                    map.invalidateSize();
                    console.log('Map size invalidated');
                }
            }, 100);

            // Add map click handler
            map.on('click', function (e) {
                // Handle map interactions
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Search input with debouncing
            document.getElementById('routeSearch').addEventListener('input', handleSearch);

            // Filter change handlers
            document.getElementById('typeFilter').addEventListener('change', applyFilters);
            document.getElementById('difficultyFilter').addEventListener('change', applyFilters);
            document.getElementById('durationFilter').addEventListener('change', applyFilters);
            document.getElementById('sortFilter').addEventListener('change', applyFilters);
        }
        // Load routes from API
        async function loadRoutes() {
            // Rate limiting kontrolü - Geliştirme için devre dışı
            // const now = Date.now();
            // if (loadingInProgress || (now - lastLoadTime) < minLoadInterval) {
            //     console.log('Rota yükleme rate limit nedeniyle atlandı');
            //     return;
            // }

            // loadingInProgress = true;  // Geliştirme için devre dışı
            // lastLoadTime = now;

            try {
                showLoading();
                const response = await rateLimitedFetch(`${apiBase}/admin/routes`, { credentials: 'include' });
                const data = await response.json();

                if (response.ok) {
                    if (Array.isArray(data)) {
                        allRoutes = data;
                    } else if (Array.isArray(data.routes)) {
                        allRoutes = data.routes;
                    } else if (Array.isArray(data.results)) {
                        allRoutes = data.results;
                    } else {
                        // Fallback: try to consolidate values if grouped
                        allRoutes = [];
                        Object.values(data || {}).forEach(val => {
                            if (Array.isArray(val)) allRoutes = allRoutes.concat(val);
                        });
                    }
                    console.log('Loaded routes:', allRoutes.map(r => ({ id: getRouteId(r), name: r.name })));
                    filteredRoutes = [...allRoutes];
                    console.log('Filtered routes:', filteredRoutes.map(r => ({ id: getRouteId(r), name: r.name })));
                    displayRoutes();
                    // Rotaları otomatik olarak haritaya yükleme - devre dışı bırakıldı
                    // await attachGeometriesToRoutes(filteredRoutes);
                    // updateMapRoutes();

                    // Auto-focus sadece seçili rota varsa
                    // setTimeout(() => {
                    //     if (Object.keys(routeLayers).length > 0) {
                    //         fitMapToRoutes();
                    //     }
                    // }, 1000);
                } else {
                    throw new Error(data.error || 'Rotalar yüklenemedi');
                }
            } catch (error) {
                console.error('Routes load error:', error);
                showError('Rotalar yüklenirken hata oluştu: ' + error.message);
            } finally {
                loadingInProgress = false;
            }
        }
        // Display routes in sidebar
        function displayRoutes() {
            const container = document.getElementById('routeListContainer');

            if (filteredRoutes.length === 0) {
                container.innerHTML = `
                    <div class="empty-workspace">
                        <i class="fas fa-route"></i>
                        <h5>Rota bulunamadı</h5>
                        <p>Arama kriterlerinizi değiştirin veya yeni rota oluşturun</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = filteredRoutes.map(route => {
                const rid = getRouteId(route);
                return `
                <div class="route-item ${selectedRoutes.has(rid) ? 'selected' : ''}" 
                     data-route-id="${rid}" role="button" tabindex="0" onclick="selectRoute(${rid}); return false;"
                     ondblclick="showRouteDetailsPopup(${rid}); return false;">
                    <input type="checkbox" class="route-checkbox" 
                           ${selectedRoutes.has(rid) ? 'checked' : ''}
                           onclick="toggleRouteSelection(event, ${rid}); return false;">
                    
                    <div class="route-item-header">
                        <h4 class="route-item-title">${escapeHtml(route.name)}</h4>
                        <div class="route-item-actions">
                            ${(!route.geometry || (route.geometry && !route.geometry.geometry && !route.geometry.type)) ? '<span class="badge bg-warning" title="Harita geometrisi yok">Geometri Yok</span>' : ''}
                            <button class="btn-route-info" onclick="showRouteDetailsPopup(${rid}); event.stopPropagation(); return false;" title="Rota Detayları">
                                <i class="fas fa-info-circle"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="route-type-badge route-type-${route.route_type}">
                        ${ROUTE_TYPES[route.route_type]?.icon || '🗺️'} 
                        ${ROUTE_TYPES[route.route_type]?.name || route.route_type}
                    </div>
                    
                    <div class="route-description">
                        ${escapeHtml(route.description || 'Açıklama bulunmuyor')}
                    </div>
                    
                    <div class="route-stats">
                        <div class="route-stat">
                            <i class="fas fa-clock route-stat-icon"></i>
                            <span>${route.estimated_duration || 0} dk</span>
                        </div>
                        <div class="route-stat">
                            <i class="fas fa-route route-stat-icon"></i>
                            <span>${(route.total_distance || 0).toFixed(2)} km</span>
                        </div>
                        <div class="route-stat">
                            <i class="fas fa-mountain route-stat-icon"></i>
                            <span>${route.elevation_gain || 0} m</span>
                        </div>
                        <div class="route-stat">
                            <i class="fas fa-star route-stat-icon"></i>
                            <span class="difficulty-stars">${getDifficultyStars(route.difficulty_level)}</span>
                        </div>
                    </div>
                    
                    ${route.is_circular ? '<div class="badge bg-info">Dairesel</div>' : ''}
                    ${route.tags ? `<div class="route-tags">${route.tags}</div>` : ''}
                </div>`;
            }).join('');

            updateBulkActions();
        }

        // Handle search with debouncing
        function handleSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                applyFilters();
            }, 800); // Arama için daha uzun bekleme süresi
        }

        // Apply all filters
        async function applyFilters() {
            const searchTerm = document.getElementById('routeSearch').value.toLowerCase();
            const typeFilter = document.getElementById('typeFilter').value;
            const difficultyFilter = document.getElementById('difficultyFilter').value;
            const durationFilter = document.getElementById('durationFilter').value;
            const sortFilter = document.getElementById('sortFilter').value;

            // Filter routes
            filteredRoutes = allRoutes.filter(route => {
                // Search filter
                if (searchTerm && !route.name.toLowerCase().includes(searchTerm) &&
                    !route.description?.toLowerCase().includes(searchTerm) &&
                    !route.tags?.toLowerCase().includes(searchTerm)) {
                    return false;
                }

                // Type filter
                if (typeFilter && route.route_type !== typeFilter) {
                    return false;
                }

                // Difficulty filter
                if (difficultyFilter && route.difficulty_level != difficultyFilter) {
                    return false;
                }

                // Duration filter
                if (durationFilter && route.estimated_duration > parseInt(durationFilter)) {
                    return false;
                }

                return true;
            });

            // --- Helpers: ID and parsing ---
            function getRouteId(route) {
                return route?.id ?? route?._id ?? route?.route_id ?? null;
            }

            function getPoiId(poi) {
                // Try different ID field names in order of preference
                return poi?.id ?? poi?._id ?? poi?.poi_id ?? null;
            }

            // Sort routes
            filteredRoutes.sort((a, b) => {
                switch (sortFilter) {
                    case 'name_asc':
                        return a.name.localeCompare(b.name);
                    case 'name_desc':
                        return b.name.localeCompare(a.name);
                    case 'created_desc':
                        return new Date(b.created_at) - new Date(a.created_at);
                    case 'created_asc':
                        return new Date(a.created_at) - new Date(b.created_at);
                    case 'difficulty_asc':
                        return a.difficulty_level - b.difficulty_level;
                    case 'difficulty_desc':
                        return b.difficulty_level - a.difficulty_level;
                    case 'duration_asc':
                        return (a.estimated_duration || 0) - (b.estimated_duration || 0);
                    case 'duration_desc':
                        return (b.estimated_duration || 0) - (a.estimated_duration || 0);
                    default:
                        return 0;
                }
            });

            displayRoutes();
            // Filtreleme sırasında da otomatik harita güncelleme devre dışı
            // await attachGeometriesToRoutes(filteredRoutes);

            // Sadece seçili rota varsa haritayı güncelle
            // if (!currentRoute) {
            //     updateMapRoutes();
            // }
        }

        // Select a route
        function selectRoute(routeId) {
            currentRoute = allRoutes.find(r => getRouteId(r) === routeId);
            if (currentRoute) {
                // Update UI selection
                document.querySelectorAll('.route-item').forEach(item => {
                    item.classList.remove('selected');
                });
                const selectedElement = document.querySelector(`[data-route-id="${routeId}"]`);
                if (selectedElement) {
                    selectedElement.classList.add('selected');
                }

                // Display route details in workspace
                displayRouteDetails(currentRoute);

                // Highlight and focus on the selected route
                highlightAndFocusRoute(currentRoute);

                // Ensure media section is initialized for the selected route
                setTimeout(async () => {
                    try {
                        await loadRouteMediaForEdit(routeId);
                    } catch (error) {
                        console.warn('Failed to initialize media for selected route:', error);
                    }
                }, 1000);
            }
        }

        // Toggle route selection for bulk operations
        function toggleRouteSelection(event, routeId) {
            event.stopPropagation();

            if (selectedRoutes.has(routeId)) {
                selectedRoutes.delete(routeId);
            } else {
                selectedRoutes.add(routeId);
            }

            updateBulkActions();
            displayRoutes();
            // When checkboxes change, redraw map for selected set
            updateMapRoutes();
        }

        // Update bulk actions visibility and count
        function updateBulkActions() {
            const bulkActions = document.getElementById('bulkActions');
            const bulkCount = document.getElementById('bulkCount');

            if (selectedRoutes.size > 0) {
                bulkActions.classList.add('show');
                bulkCount.textContent = `${selectedRoutes.size} rota seçildi`;
            } else {
                bulkActions.classList.remove('show');
            }
        }

        // Clear selection
        function clearSelection() {
            selectedRoutes.clear();
            updateBulkActions();
            displayRoutes();
        }

        // Clear route selection and show all routes
        function clearRouteSelection() {
            currentRoute = null;

            // Update map title
            updateMapTitle();

            // Remove UI selection
            document.querySelectorAll('.route-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Reset all route styles to normal
            Object.entries(routeLayers).forEach(([id, layer]) => {
                const routeData = allRoutes.find(r => String(getRouteId(r)) === String(id));
                if (routeData) {
                    const color = ROUTE_TYPES[routeData.route_type]?.color || '#2563eb';
                    layer.setStyle({
                        color: color,
                        weight: 3,
                        opacity: 0.7
                    });
                }
            });

            // Clear POI markers
            if (poiMarkersLayer) {
                poiMarkersLayer.clearLayers();
            }

            // Show empty workspace
            document.getElementById('workspaceContent').innerHTML = `
                <div class="empty-workspace">
                    <i class="fas fa-route"></i>
                    <h4>Rota Seçin</h4>
                    <p>Detayları görüntülemek için sol taraftan bir rota seçin</p>
                </div>
            `;

            // Hide workspace actions
            document.getElementById('workspaceActions').style.display = 'none';

            // Fit map to all routes
            fitMapToRoutes();
        }
        // Display route details in workspace
        async function displayRouteDetails(route) {
            const workspaceTitle = document.getElementById('workspaceTitle');
            const workspaceActions = document.getElementById('workspaceActions');
            const workspaceContent = document.getElementById('workspaceContent');

            const rid = getRouteId(route);
            let routeDetails = route;
            if (!route.elevation_profile || !route.pois || !route.geometry) {
                try {
                    const resp = await fetch(`${apiBase}/admin/routes/${rid}`, { credentials: 'include' });
                    if (resp.ok) {
                        routeDetails = await resp.json();
                        currentRoute = routeDetails;
                    }
                } catch (err) {
                    console.warn('Rota detayları alınamadı:', err);
                }
            }

            workspaceTitle.textContent = routeDetails.name;
            workspaceActions.innerHTML = defaultWorkspaceActionsHTML;
            workspaceActions.style.display = 'flex';

            workspaceContent.innerHTML = `
                <div class="route-detail-view">
                    <div class="route-detail-header">
                        <div class="route-type-badge route-type-${routeDetails.route_type}">
                            ${ROUTE_TYPES[routeDetails.route_type]?.icon || '🗺️'}
                            ${ROUTE_TYPES[routeDetails.route_type]?.name || routeDetails.route_type}
                        </div>
                        <div class="difficulty-display">
                            <span class="difficulty-stars">${getDifficultyStars(routeDetails.difficulty_level)}</span>
                            <span class="difficulty-text">Zorluk: ${routeDetails.difficulty_level}/5</span>
                        </div>
                    </div>

                    <div class="route-description-full">
                        <h5><i class="fas fa-info-circle me-2"></i>Açıklama</h5>
                        <p>${escapeHtml(routeDetails.description || 'Açıklama bulunmuyor')}</p>
                    </div>

                    <div class="route-statistics">
                        <h5><i class="fas fa-chart-bar me-2"></i>İstatistikler</h5>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-icon">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-value">${routeDetails.estimated_duration || 0}</div>
                                    <div class="stat-label">Dakika</div>
                                </div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">
                                    <i class="fas fa-route"></i>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-value">${(routeDetails.total_distance || 0).toFixed(2)}</div>
                                    <div class="stat-label">Kilometre</div>
                                </div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">
                                    <i class="fas fa-mountain"></i>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-value">${routeDetails.elevation_gain || 0}</div>
                                    <div class="stat-label">Yükselti (m)</div>
                                </div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">
                                    <i class="fas fa-map-marker-alt"></i>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-value">${routeDetails.poi_count || 0}</div>
                                    <div class="stat-label">POI Sayısı</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    ${routeDetails.tags ? `
                        <div class="route-tags-section">
                            <h5><i class="fas fa-tags me-2"></i>Etiketler</h5>
                            <div class="tags-container">
                                ${routeDetails.tags.split(',').map(tag =>
                `<span class="tag-chip">${escapeHtml(tag.trim())}</span>`
            ).join('')}
                            </div>
                        </div>
                    ` : ''}

                    <div class="route-metadata">
                        <h5><i class="fas fa-info me-2"></i>Metadata</h5>
                        <div class="metadata-grid">
                            <div class="metadata-item">
                                <strong>Oluşturulma:</strong>
                                <span>${formatDate(routeDetails.created_at)}</span>
                            </div>
                            <div class="metadata-item">
                                <strong>Güncellenme:</strong>
                                <span>${formatDate(routeDetails.updated_at)}</span>
                            </div>
                            <div class="metadata-item">
                                <strong>Dairesel Rota:</strong>
                                <span>${routeDetails.is_circular ? 'Evet' : 'Hayır'}</span>
                            </div>
                            ${routeDetails.import_source ? `
                                <div class="metadata-item">
                                    <strong>Import Kaynağı:</strong>
                                    <span>${escapeHtml(routeDetails.import_source)}</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>

                    <!-- Route Media Section -->
                    <div class="route-media-section">
                        <h5><i class="fas fa-images me-2"></i>Medya Dosyaları</h5>
                        <div class="route-media-controls mb-3">
                            <button type="button" class="btn btn-primary btn-sm" onclick="showRouteMediaUploadForm()">
                                <i class="fas fa-plus me-1"></i>Medya Ekle
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" onclick="refreshRouteMedia()">
                                <i class="fas fa-sync-alt me-1"></i>Yenile
                            </button>
                            <button type="button" class="btn btn-outline-warning btn-sm" onclick="debugMediaDisplay('${rid}')" title="Medya görüntüleme sorunlarını debug et">
                                <i class="fas fa-bug me-1"></i>Debug
                            </button>
                        </div>
                        <div id="routeCurrentMedia" class="current-media-grid">
                            <div class="loading-spinner">
                                <div class="spinner"></div>
                                <p>Medya dosyaları yükleniyor...</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add CSS for route detail view
            addRouteDetailStyles();

            // Load elevation chart for route manager
            if (window.ElevationChart && routeDetails) {

                setTimeout(async () => {
                    if (!window.routeElevationChart) {
                        window.routeElevationChart = new ElevationChart('routeElevationChartContainer', map);
                    }

                    if (routeDetails.elevation_profile && routeDetails.elevation_profile.points) {
                        await window.routeElevationChart.loadElevationProfile(routeDetails.elevation_profile);
                    } else if (routeDetails.geometry) {

                        await window.routeElevationChart.loadRouteElevation({
                            geometry: routeDetails.geometry
                        });
                    } else if (routeDetails.pois && routeDetails.pois.length > 0) {
                        await window.routeElevationChart.loadRouteElevation({
                            pois: routeDetails.pois.map(poi => ({
                                name: poi.name,
                                latitude: poi.latitude || poi.lat,
                                longitude: poi.longitude || poi.lng || poi.lon
                            }))
                        });
                    }
                }, 500);
            }

            // Also refresh media for the selected route
            setTimeout(async () => {
                try {
                    console.log('Loading media for route details, routeId:', rid);
                    await loadRouteMediaForEdit(rid);
                    console.log('Media loaded successfully for route details');
                } catch (error) {
                    console.warn('Failed to load media for route details:', error);
                }
            }, 800);
        }

        // Show route details in a popup modal
        async function showRouteDetailsPopup(routeId) {
            let route = allRoutes.find(r => getRouteId(r) === routeId);
            try {
                const resp = await fetch(`${apiBase}/admin/routes/${routeId}`, { credentials: 'include' });
                if (resp.ok) {
                    route = await resp.json();
                }
            } catch (err) {
                console.warn('Rota detayları alınamadı:', err);
            }
            if (!route) {
                console.error('Route not found:', routeId);
                return;
            }

            const modalHtml = `
                <div class="modal fade" id="routeDetailsModal" tabindex="-1">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">
                                    <i class="fas fa-route me-2"></i>
                                    Rota Detayları - ${escapeHtml(route.name)}
                                </h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <div class="route-detail-popup">
                                    <div class="route-detail-header">
                                        <div class="route-type-badge route-type-${route.route_type}">
                                            ${ROUTE_TYPES[route.route_type]?.icon || '🗺️'} 
                                            ${ROUTE_TYPES[route.route_type]?.name || route.route_type}
                                        </div>
                                        <div class="difficulty-display">
                                            <span class="difficulty-stars">${getDifficultyStars(route.difficulty_level)}</span>
                                            <span class="difficulty-text">Zorluk: ${route.difficulty_level}/5</span>
                                        </div>
                                    </div>

                                    <div class="route-description-full">
                                        <h6><i class="fas fa-info-circle me-2"></i>Açıklama</h6>
                                        <p>${escapeHtml(route.description || 'Açıklama bulunmuyor')}</p>
                                    </div>

                                    <div class="route-statistics">
                                        <h6><i class="fas fa-chart-bar me-2"></i>İstatistikler</h6>
                                        <div class="stats-grid-popup">
                                            <div class="stat-card-popup">
                                                <div class="stat-icon">
                                                    <i class="fas fa-clock"></i>
                                                </div>
                                                <div class="stat-info">
                                                    <div class="stat-value">${route.estimated_duration || 0}</div>
                                                    <div class="stat-label">Dakika</div>
                                                </div>
                                            </div>
                                            <div class="stat-card-popup">
                                                <div class="stat-icon">
                                                    <i class="fas fa-route"></i>
                                                </div>
                                                <div class="stat-info">
                                                    <div class="stat-value">${(route.total_distance || 0).toFixed(2)}</div>
                                                    <div class="stat-label">Kilometre</div>
                                                </div>
                                            </div>
                                            <div class="stat-card-popup">
                                                <div class="stat-icon">
                                                    <i class="fas fa-mountain"></i>
                                                </div>
                                                <div class="stat-info">
                                                    <div class="stat-value">${route.elevation_gain || 0}</div>
                                                    <div class="stat-label">Yükselti (m)</div>
                                                </div>
                                            </div>
                                            <div class="stat-card-popup">
                                                <div class="stat-icon">
                                                    <i class="fas fa-map-marker-alt"></i>
                                                </div>
                                                <div class="stat-info">
                                                    <div class="stat-value">${route.poi_count || 0}</div>
                                                    <div class="stat-label">POI Sayısı</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    ${route.tags ? `
                                        <div class="route-tags-section">
                                            <h6><i class="fas fa-tags me-2"></i>Etiketler</h6>
                                            <div class="tags-container">
                                                ${route.tags.split(',').map(tag =>
                `<span class="tag-chip">${escapeHtml(tag.trim())}</span>`
            ).join('')}
                                            </div>
                                        </div>
                                    ` : ''}

                                    <div class="route-metadata">
                                        <h6><i class="fas fa-info me-2"></i>Metadata</h6>
                                        <div class="metadata-grid-popup">
                                            <div class="metadata-item">
                                                <strong>Oluşturulma:</strong>
                                                <span>${formatDate(route.created_at)}</span>
                                            </div>
                                            <div class="metadata-item">
                                                <strong>Güncellenme:</strong>
                                                <span>${formatDate(route.updated_at)}</span>
                                            </div>
                                            <div class="metadata-item">
                                                <strong>Dairesel Rota:</strong>
                                                <span>${route.is_circular ? 'Evet' : 'Hayır'}</span>
                                            </div>
                                            ${route.import_source ? `
                                                <div class="metadata-item">
                                                    <strong>Import Kaynağı:</strong>
                                                    <span>${escapeHtml(route.import_source)}</span>
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-primary" onclick="selectRouteFromPopup(${routeId})">
                                    <i class="fas fa-eye me-1"></i>Rotayı Seç ve Görüntüle
                                </button>
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Kapat</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Remove existing modal if any
            const existingModal = document.getElementById('routeDetailsModal');
            if (existingModal) {
                existingModal.remove();
            }

            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('routeDetailsModal'));
            modal.show();
        }

        // Select route from popup and close modal
        function selectRouteFromPopup(routeId) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('routeDetailsModal'));
            if (modal) modal.hide();

            // Select the route
            selectRoute(routeId);
        }
        // Add styles for route detail view
        function addRouteDetailStyles() {
            if (document.getElementById('routeDetailStyles')) return;

            const style = document.createElement('style');
            style.id = 'routeDetailStyles';
            style.textContent = `
                .route-detail-view {
                    padding: 0;
                }

                .route-detail-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 1.5rem;
                    padding-bottom: 1rem;
                    border-bottom: 2px solid var(--route-border);
                }

                .difficulty-display {
                    text-align: right;
                }

                .difficulty-text {
                    display: block;
                    font-size: 0.85rem;
                    color: var(--route-secondary);
                    margin-top: 0.25rem;
                }

                .route-description-full {
                    margin-bottom: 1.5rem;
                }

                .route-description-full h5 {
                    color: var(--route-dark);
                    margin-bottom: 0.75rem;
                }

                .route-description-full p {
                    color: var(--route-secondary);
                    line-height: 1.6;
                }

                .stats-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                    gap: 1rem;
                    margin-bottom: 1.5rem;
                }

                .stat-card {
                    background: var(--route-light);
                    border-radius: var(--route-radius);
                    padding: 1rem;
                    display: flex;
                    align-items: center;
                    gap: 0.75rem;
                    border: 2px solid var(--route-border);
                    transition: var(--route-transition);
                }

                .stat-card:hover {
                    border-color: var(--route-primary);
                    transform: translateY(-2px);
                }

                .stat-icon {
                    width: 40px;
                    height: 40px;
                    background: var(--route-primary);
                    color: white;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.1rem;
                }

                .stat-value {
                    font-size: 1.25rem;
                    font-weight: 700;
                    color: var(--route-dark);
                }

                .stat-label {
                    font-size: 0.8rem;
                    color: var(--route-secondary);
                }

                .route-tags-section {
                    margin-bottom: 1.5rem;
                }

                .route-tags-section h5 {
                    color: var(--route-dark);
                    margin-bottom: 0.75rem;
                }

                .tags-container {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 0.5rem;
                }

                .tag-chip {
                    background: var(--route-primary);
                    color: white;
                    padding: 0.25rem 0.75rem;
                    border-radius: 15px;
                    font-size: 0.8rem;
                    font-weight: 500;
                }

                .route-metadata h5 {
                    color: var(--route-dark);
                    margin-bottom: 0.75rem;
                }

                .metadata-grid {
                    display: grid;
                    gap: 0.5rem;
                }

                .metadata-item {
                    display: flex;
                    justify-content: space-between;
                    padding: 0.5rem;
                    background: var(--route-light);
                    border-radius: var(--route-radius);
                    border: 1px solid var(--route-border);
                }

                .metadata-item strong {
                    color: var(--route-dark);
                }

                .metadata-item span {
                    color: var(--route-secondary);
                }

                .route-media-section {
                    margin-bottom: 1.5rem;
                    background: var(--route-light);
                    border-radius: var(--route-radius);
                    padding: 1.5rem;
                    border: 2px solid var(--route-border);
                }

                .route-media-section h5 {
                    color: var(--route-dark);
                    margin-bottom: 1rem;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                }

                .route-media-controls {
                    display: flex;
                    gap: 0.5rem;
                    flex-wrap: wrap;
                    margin-bottom: 1rem;
                }

                .route-media-controls .btn {
                    font-size: 0.85rem;
                    padding: 0.375rem 0.75rem;
                }

                .route-media-section .current-media-grid {
                    margin-top: 0;
                }
            `;
            document.head.appendChild(style);
        }
        // Update map with filtered routes
        async function updateMapRoutes() {
            console.log('=== updateMapRoutes called ===');
            console.log('filteredRoutes count:', filteredRoutes.length);
            console.log('map object:', map);
            console.log('routeLayers before clear:', Object.keys(routeLayers));

            // Clear existing route layers
            Object.values(routeLayers).forEach(layer => {
                map.removeLayer(layer);
            });
            routeLayers = {};
            console.log('Route layers cleared');

            // Determine which routes to draw (reverted to drawing all filtered routes)
            const drawingRoutes = filteredRoutes;
            console.log('Drawing filteredRoutes:', drawingRoutes.map(r => getRouteId(r)));

            // Add chosen routes to map
            for (const route of drawingRoutes) {
                console.log('Processing route:', route.name, 'ID:', getRouteId(route));
                const color = ROUTE_TYPES[route.route_type]?.color || '#2563eb';
                let layer = null;
                try {
                    if (route.geometry) {
                        let geo = route.geometry;
                        console.log('Original geometry for route', route.name, ':', geo);
                        if (typeof geo === 'string') {
                            try { geo = JSON.parse(geo); } catch (e) { console.warn('geometry not JSON string:', e); }
                        }

                        // Handle nested geometry structure from API
                        if (geo && geo.geometry && geo.geometry.type && geo.geometry.coordinates) {
                            geo = geo.geometry; // Extract the actual GeoJSON
                        }

                        console.log('Parsed geometry:', geo);
                        if (geo && typeof geo === 'object' && !Array.isArray(geo) && geo.type && geo.coordinates) {
                            // Valid GeoJSON object
                            console.log('Attempting L.geoJSON with valid GeoJSON:', geo);
                            layer = L.geoJSON(geo, { style: { color, weight: 3, opacity: 0.7 } });
                            console.log('L.geoJSON layer created:', layer ? 'SUCCESS' : 'FAILED');

                            if (layer) {
                                layer.bindPopup(`
                                    <strong>${escapeHtml(route.name)}</strong><br>
                                    ${ROUTE_TYPES[route.route_type]?.name || route.route_type}<br>
                                    ${route.estimated_duration || 0} dakika
                                `);

                                const rid = getRouteId(route);
                                routeLayers[rid] = layer;
                                layer.addTo(map);
                                console.log('Static geometry layer added for route:', route.name, 'ID:', rid);
                            }
                        } else if (Array.isArray(geo)) {
                            // Assume array of [lng, lat] or [lat, lng]
                            const latlngs = geo.map(p => {
                                if (Array.isArray(p)) {
                                    const a = Number(p[0]);
                                    const b = Number(p[1]);
                                    if (!isNaN(a) && !isNaN(b)) {
                                        if (a >= -180 && a <= 180 && b >= -90 && b <= 90) {
                                            return [b, a];
                                        }
                                        return [a, b];
                                    }
                                }
                                return [p.lat || p.latitude, p.lng || p.longitude];
                            });
                            layer = L.polyline(latlngs, { color, weight: 3, opacity: 0.7 });
                        }
                    } else {
                        console.log('No geometry found for route:', route.name, 'trying POI fallback directly...');
                        // Try POI fallback immediately for routes without geometry
                        const rid = getRouteId(route);
                        if (rid) {
                            try {
                                const rd = await fetch(`${apiBase}/admin/routes/${rid}`, { credentials: 'include' });
                                if (rd.ok) {
                                    const rj = await rd.json();
                                    console.log('Direct POI route detail response:', rj);
                                    const pois = Array.isArray(rj?.pois) ? rj.pois : [];
                                    console.log('Direct POI found for route:', pois.length);
                                    if (pois.length >= 2) {
                                        const latlngs = pois
                                            .sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0))
                                            .map(p => [Number(p.lat || p.latitude), Number(p.lon || p.longitude)])
                                            .filter(arr => Number.isFinite(arr[0]) && Number.isFinite(arr[1]));
                                        console.log('Direct POI valid coordinates:', latlngs);
                                        if (latlngs.length >= 2) {
                                            // Use smart routing API to get real road network route
                                            try {
                                                const waypoints = pois
                                                    .sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0))
                                                    .map(p => ({
                                                        lat: Number(p.lat || p.latitude),
                                                        lng: Number(p.lon || p.longitude),
                                                        name: p.name
                                                    }))
                                                    .filter(wp => Number.isFinite(wp.lat) && Number.isFinite(wp.lng));

                                                console.log('Creating smart route with waypoints:', waypoints);

                                                const routeResponse = await fetch('/api/route/smart', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    credentials: 'include',
                                                    body: JSON.stringify({ waypoints })
                                                });

                                                if (routeResponse.ok) {
                                                    const routeData = await routeResponse.json();
                                                    console.log('Smart route response:', routeData);
                                                    console.log('Route data structure:', Object.keys(routeData));
                                                    console.log('Route.route structure:', routeData.route ? Object.keys(routeData.route) : 'no route key');

                                                    // Check ALL possible response structures
                                                    let allCoords = [];

                                                    // Prefer route.segments[].coordinates [{lat,lng}, ...]
                                                    if (routeData.route && Array.isArray(routeData.route.segments) && routeData.route.segments.length > 0) {
                                                        routeData.route.segments.forEach(seg => {
                                                            if (Array.isArray(seg?.coordinates) && seg.coordinates.length > 0) {
                                                                seg.coordinates.forEach(pt => {
                                                                    const lat = Number(pt.lat);
                                                                    const lng = Number(pt.lng);
                                                                    if (Number.isFinite(lat) && Number.isFinite(lng)) allCoords.push([lat, lng]);
                                                                });
                                                            }
                                                        });
                                                        console.log('Using route.segments.coordinates:', allCoords.length);
                                                    } else if (routeData.route && routeData.route.geometry && Array.isArray(routeData.route.geometry)) {
                                                        allCoords = routeData.route.geometry;
                                                        console.log('Using route.geometry:', allCoords.length);
                                                    } else if (routeData.route && routeData.route.coordinates && Array.isArray(routeData.route.coordinates)) {
                                                        allCoords = routeData.route.coordinates;
                                                        console.log('Using route.coordinates:', allCoords.length);
                                                    } else if (routeData.segments && Array.isArray(routeData.segments)) {
                                                        routeData.segments.forEach(segment => {
                                                            if (Array.isArray(segment)) allCoords.push(...segment);
                                                        });
                                                        console.log('Using segments:', allCoords.length);
                                                    } else if (routeData.route && routeData.route.segments && Array.isArray(routeData.route.segments)) {
                                                        routeData.route.segments.forEach(segment => {
                                                            if (Array.isArray(segment)) allCoords.push(...segment);
                                                        });
                                                        console.log('Using route.segments (array arrays):', allCoords.length);
                                                    } else {
                                                        console.log('No recognized route format found, trying fallback to waypoints');
                                                        // Fallback: use original waypoints
                                                        allCoords = waypoints.map(wp => [wp.lat, wp.lng]);
                                                    }

                                                    if (allCoords.length >= 2) {
                                                        layer = L.polyline(allCoords, { color, weight: 4, opacity: 0.8 });
                                                        layer.bindPopup(`
                                            <strong>${escapeHtml(route.name)}</strong><br>
                                            ${ROUTE_TYPES[route.route_type]?.name || route.route_type}<br>
                                            ${Math.round(routeData.total_distance || 0)} km<br>
                                            ${Math.round(routeData.estimated_time || 0)} dakika<br>
                                            <small>Yol ağından hesaplandı</small>
                                        `);
                                                        routeLayers[rid] = layer;
                                                        layer.addTo(map);
                                                        console.log('Smart route added for:', route.name);
                                                    }
                                                } else {
                                                    throw new Error('Smart route API failed');
                                                }
                                            } catch (smartRouteError) {
                                                console.warn('Smart route failed, falling back to simple polyline:', smartRouteError);
                                                // Fallback to simple polyline
                                                layer = L.polyline(latlngs, { color, weight: 4, opacity: 0.8 });
                                                layer.bindPopup(`
                                                    <strong>${escapeHtml(route.name)}</strong><br>
                                                    ${ROUTE_TYPES[route.route_type]?.name || route.route_type}<br>
                                                    ${route.estimated_duration || 0} dakika<br>
                                                    <small>Düz çizgi (yol ağı bulunamadı)</small>
                                                `);
                                                routeLayers[rid] = layer;
                                                layer.addTo(map);
                                                console.log('Fallback polyline added for route:', route.name);
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('Direct POI fallback failed:', e);
                            }
                        }

                        // Original geometry fetch fallback
                        // Try lazy fetch of geometry and retry once
                        try {
                            const rid = getRouteId(route);
                            if (rid) {
                                console.log('Fetching geometry for route ID:', rid);
                                const res = await fetch(`${apiBase}/routes/${rid}/geometry`, { credentials: 'include' });
                                if (res.ok) {
                                    const g = await res.json();
                                    console.log('Geometry response:', g);
                                    if (g && g.geometry) {
                                        let geo = g.geometry;
                                        if (typeof geo === 'string') {
                                            try { geo = JSON.parse(geo); } catch (e) { }
                                        }
                                        route.geometry = geo;
                                        // Retry build
                                        if (geo && typeof geo === 'object') {
                                            layer = L.geoJSON(geo, { style: { color, weight: 3, opacity: 0.7 } });
                                        }
                                        if (layer) {
                                            layer.bindPopup(`
                                                <strong>${escapeHtml(route.name)}</strong><br>
                                                ${ROUTE_TYPES[route.route_type]?.name || route.route_type}<br>
                                                ${route.estimated_duration || 0} dakika
                                            `);
                                        } else if (res.status === 404) {
                                            console.warn(`Route ${rid} geometry not found (404) - skipping map display`);
                                            // Route has no geometry, skip adding to map but don't show error
                                            continue;
                                        } else {
                                            console.error(`Failed to fetch geometry for route ${rid}: ${res.status}`);
                                            continue;
                                            const rid2 = getRouteId(route);
                                            routeLayers[rid2] = layer;
                                            layer.addTo(map);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('Lazy geometry fetch failed:', e);
                        }
                    }
                } catch (error) {
                    console.warn('Route geometry parse error:', error);
                    console.log('ERROR CAUGHT! Now trying POI fallback for route:', route.name);
                    const rid = getRouteId(route);
                    console.log('Route ID for POI fallback:', rid);
                    if (rid) {
                        console.log('Geometry failed, trying POI fallback for route:', route.name);
                        try {
                            const rd = await fetch(`${apiBase}/admin/routes/${rid}`, { credentials: 'include' });
                            if (rd.ok) {
                                const rj = await rd.json();
                                console.log('Route detail response:', rj);
                                const pois = Array.isArray(rj?.pois) ? rj.pois : [];
                                console.log('Found POIs for route:', pois.length);
                                if (pois.length >= 2) {
                                    const latlngs = pois
                                        .sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0))
                                        .map(p => [Number(p.lat || p.latitude), Number(p.lon || p.longitude)])
                                        .filter(arr => Number.isFinite(arr[0]) && Number.isFinite(arr[1]));
                                    console.log('Valid coordinates:', latlngs);
                                    if (latlngs.length >= 2) {
                                        // Smart routing for error fallback
                                        try {
                                            const waypoints = pois
                                                .sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0))
                                                .map(p => ({
                                                    lat: Number(p.lat || p.latitude),
                                                    lng: Number(p.lon || p.longitude),
                                                    name: p.name
                                                }))
                                                .filter(wp => Number.isFinite(wp.lat) && Number.isFinite(wp.lng));

                                            const routeResponse = await fetch('/api/route/smart', {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/json' },
                                                credentials: 'include',
                                                body: JSON.stringify({ waypoints })
                                            });

                                            if (routeResponse.ok) {
                                                const routeData = await routeResponse.json();
                                                if (routeData.route && Array.isArray(routeData.route.segments)) {
                                                    const coords = [];
                                                    routeData.route.segments.forEach(seg => {
                                                        if (Array.isArray(seg?.coordinates)) {
                                                            seg.coordinates.forEach(pt => {
                                                                const lat = Number(pt.lat);
                                                                const lng = Number(pt.lng);
                                                                if (Number.isFinite(lat) && Number.isFinite(lng)) coords.push([lat, lng]);
                                                            });
                                                        }
                                                    });
                                                    if (coords.length >= 2) {
                                                        layer = L.polyline(coords, { color, weight: 4, opacity: 0.8 });
                                                        layer.bindPopup(`
                                                            <strong>${escapeHtml(route.name)}</strong><br>
                                                            ${ROUTE_TYPES[route.route_type]?.name || route.route_type}<br>
                                                            <small>Yol ağından hesaplandı</small>
                                                        `);
                                                        routeLayers[rid] = layer;
                                                        layer.addTo(map);
                                                        console.log('Smart route added from error fallback:', route.name);
                                                    }
                                                }
                                            } else {
                                                throw new Error('Smart route failed');
                                            }
                                        } catch (smartError) {
                                            console.warn('Smart routing failed in error fallback, using simple polyline:', smartError);
                                            layer = L.polyline(latlngs, { color, weight: 4, opacity: 0.8 });
                                            layer.bindPopup(`
                                                <strong>${escapeHtml(route.name)}</strong><br>
                                                ${ROUTE_TYPES[route.route_type]?.name || route.route_type}<br>
                                                ${route.estimated_duration || 0} dakika<br>
                                                <small>Düz çizgi (yol ağı bulunamadı)</small>
                                            `);
                                            routeLayers[rid] = layer;
                                            layer.addTo(map);
                                            console.log('Final fallback polyline for route:', route.name);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('POI fallback failed:', e);
                        }
                    }
                }
            }

            // Fit map to show all drawn routes
            console.log('Total route layers added:', Object.keys(routeLayers).length);
            if (Object.keys(routeLayers).length > 0) {
                const group = new L.featureGroup(Object.values(routeLayers));
                map.fitBounds(group.getBounds(), { padding: [20, 20] });
                console.log('Map fitted to route bounds');
            } else {
                console.log('No route layers to display, invalidating map size');
                setTimeout(() => { try { map.invalidateSize(); } catch (e) { } }, 100);
            }
        }

        // Update map title based on selected route
        function updateMapTitle(route = null) {
            const mapTitle = document.getElementById('mapTitle');
            if (route) {
                mapTitle.innerHTML = `
                    <i class="fas fa-map me-2"></i>
                    <span style="color: ${ROUTE_TYPES[route.route_type]?.color || '#2563eb'}">
                        ${escapeHtml(route.name)}
                    </span>
                `;
            } else {
                mapTitle.innerHTML = `
                    <i class="fas fa-map me-2"></i>
                    Harita Görünümü
                `;
            }
        }

        // Highlight and focus on selected route - sadece seçili rotayı göster
        async function highlightAndFocusRoute(route) {
            console.log('Highlighting and focusing on route:', route.name);

            const rid = getRouteId(route);
            if (!rid) {
                console.warn('No route ID found');
                return;
            }

            // Update map title
            updateMapTitle(route);

            // Önce tüm rotaları haritadan kaldır
            clearAllRoutesFromMap();

            // Sadece seçili rotayı haritaya ekle
            await showSingleRouteOnMap(route);

                            // Seçili rotanın POI'lerini yükle ve göster
                setTimeout(async () => {
                    await loadAndDisplayRoutePOIs(rid);
                    // Refresh photo location markers
                    refreshPhotoLocationMarkers();
                }, 100);
        }

        // Load and display POI markers for a specific route
        async function loadAndDisplayRoutePOIs(routeId) {
            if (!poiMarkersLayer) return;

            // Clear existing POI markers
            poiMarkersLayer.clearLayers();

            try {
                const routeDetailResp = await fetch(`${apiBase}/admin/routes/${routeId}`, { credentials: 'include' });

                if (routeDetailResp.ok) {
                    const routeDetail = await routeDetailResp.json();
                    const pois = Array.isArray(routeDetail?.pois) ? routeDetail.pois : [];

                    if (pois.length > 0) {
                        console.log('Adding POI markers for route:', pois.length);

                        // Sort POIs by order
                        const sortedPois = pois.sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0));

                        // Add POI markers with category icons
                        sortedPois.forEach((poi, index) => {
                            const lat = Number(poi.lat || poi.latitude);
                            const lng = Number(poi.lon || poi.longitude);

                            if (Number.isFinite(lat) && Number.isFinite(lng)) {
                                // Get category info for custom icon
                                const category = POI_CATEGORIES[poi.category] || {
                                    icon: 'map-marker-alt',
                                    color: '#2563eb',
                                    name: poi.category || 'Kategori yok'
                                };

                                // Create custom POI icon
                                const customIcon = L.divIcon({
                                    className: 'custom-poi-marker',
                                    html: `
                                        <div class="poi-marker-container" style="background-color: ${category.color}">
                                            <i class="fas fa-${category.icon}"></i>
                                            <div class="poi-order-number">${poi.order_in_route || index + 1}</div>
                                        </div>
                                    `,
                                    iconSize: [35, 35],
                                    iconAnchor: [17, 35],
                                    popupAnchor: [0, -35]
                                });

                                const marker = L.marker([lat, lng], {
                                    icon: customIcon,
                                    title: poi.name || `POI ${index + 1}`
                                });

                                marker.bindPopup(`
                                    <div class="poi-popup">
                                        <div class="poi-popup-header">
                                            <i class="fas fa-${category.icon}" style="color: ${category.color}"></i>
                                            <strong>${escapeHtml(poi.name || 'POI')}</strong>
                                        </div>
                                        <div class="poi-popup-category">${category.name}</div>
                                        ${poi.description ? `<div class="poi-popup-description">${escapeHtml(poi.description.substring(0, 100))}${poi.description.length > 100 ? '...' : ''}</div>` : ''}
                                        <div class="poi-popup-order">Sıra: ${poi.order_in_route || index + 1}</div>
                                    </div>
                                `);

                                poiMarkersLayer.addLayer(marker);
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading route POIs:', error);
            }
        }

        // Show selected route on map with focus
        async function showSelectedRouteOnMap(route) {
            console.log('=== showSelectedRouteOnMap called ===');
            console.log('Selected route:', route.name, 'ID:', getRouteId(route));

            const rid = getRouteId(route);
            if (!rid) {
                console.warn('No route ID found');
                return;
            }

            // Clear existing route layers to show only selected route
            Object.values(routeLayers).forEach(layer => {
                try { map.removeLayer(layer); } catch (e) { }
            });
            routeLayers = {};

            // Clear POI markers
            if (poiMarkersLayer) {
                poiMarkersLayer.clearLayers();
            }

            let routeLayer = null;
            const color = ROUTE_TYPES[route.route_type]?.color || '#2563eb';

            try {
                // First try to use existing geometry
                if (route.geometry) {
                    let geo = route.geometry;
                    if (typeof geo === 'string') {
                        try { geo = JSON.parse(geo); } catch (e) { console.warn('geometry not JSON:', e); }
                    }

                    if (geo && typeof geo === 'object' && geo.type && geo.coordinates) {
                        routeLayer = L.geoJSON(geo, {
                            style: { color, weight: 4, opacity: 0.9 }
                        });
                        console.log('Route created from existing geometry');
                    }
                }

                // If no geometry, try to build from POIs
                if (!routeLayer) {
                    console.log('No geometry found, trying POI-based route');
                    const routeDetailResp = await fetch(`${apiBase}/admin/routes/${rid}`, { credentials: 'include' });

                    if (routeDetailResp.ok) {
                        const routeDetail = await routeDetailResp.json();
                        const pois = Array.isArray(routeDetail?.pois) ? routeDetail.pois : [];
                        console.log('Found POIs for route:', pois.length);

                        if (pois.length >= 2) {
                            // Sort POIs by order
                            const sortedPois = pois.sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0));

                            // Create waypoints for smart routing
                            const waypoints = sortedPois
                                .map(p => ({
                                    lat: Number(p.lat || p.latitude),
                                    lng: Number(p.lon || p.longitude),
                                    name: p.name
                                }))
                                .filter(wp => Number.isFinite(wp.lat) && Number.isFinite(wp.lng));

                            console.log('Waypoints for smart routing:', waypoints.length);

                            if (waypoints.length >= 2) {
                                try {
                                    // Try smart routing first
                                    const routeResponse = await fetch('/api/route/smart', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        credentials: 'include',
                                        body: JSON.stringify({ waypoints })
                                    });

                                    if (routeResponse.ok) {
                                        const routeData = await routeResponse.json();
                                        console.log('Smart route response:', routeData);

                                        let allCoords = [];

                                        // Extract coordinates from smart route response
                                        if (routeData.route && Array.isArray(routeData.route.segments)) {
                                            routeData.route.segments.forEach(seg => {
                                                if (Array.isArray(seg?.coordinates)) {
                                                    seg.coordinates.forEach(pt => {
                                                        const lat = Number(pt.lat);
                                                        const lng = Number(pt.lng);
                                                        if (Number.isFinite(lat) && Number.isFinite(lng)) {
                                                            allCoords.push([lat, lng]);
                                                        }
                                                    });
                                                }
                                            });
                                        }

                                        if (allCoords.length >= 2) {
                                            routeLayer = L.polyline(allCoords, {
                                                color, weight: 4, opacity: 0.9
                                            });
                                            console.log('Smart route layer created');
                                        }
                                    }
                                } catch (smartError) {
                                    console.warn('Smart routing failed:', smartError);
                                }

                                // Fallback to simple polyline if smart routing failed
                                if (!routeLayer) {
                                    const simpleCoords = waypoints.map(wp => [wp.lat, wp.lng]);
                                    routeLayer = L.polyline(simpleCoords, {
                                        color, weight: 4, opacity: 0.9
                                    });
                                    console.log('Fallback polyline created');
                                }
                            }

                            // Add POI markers with category icons
                            sortedPois.forEach((poi, index) => {
                                const lat = Number(poi.lat || poi.latitude);
                                const lng = Number(poi.lon || poi.longitude);

                                if (Number.isFinite(lat) && Number.isFinite(lng)) {
                                    // Get category info for custom icon
                                    const category = POI_CATEGORIES[poi.category] || {
                                        icon: 'map-marker-alt',
                                        color: '#2563eb',
                                        name: poi.category || 'Kategori yok'
                                    };

                                    // Create custom POI icon
                                    const customIcon = L.divIcon({
                                        className: 'custom-poi-marker',
                                        html: `
                                            <div class="poi-marker-container" style="background-color: ${category.color}">
                                                <i class="fas fa-${category.icon}"></i>
                                                <div class="poi-order-number">${poi.order_in_route || index + 1}</div>
                                            </div>
                                        `,
                                        iconSize: [35, 35],
                                        iconAnchor: [17, 35],
                                        popupAnchor: [0, -35]
                                    });

                                    const marker = L.marker([lat, lng], {
                                        icon: customIcon,
                                        title: poi.name || `POI ${index + 1}`
                                    });

                                    marker.bindPopup(`
                                        <div class="poi-popup">
                                            <div class="poi-popup-header">
                                                <i class="fas fa-${category.icon}" style="color: ${category.color}"></i>
                                                <strong>${escapeHtml(poi.name || 'POI')}</strong>
                                            </div>
                                            <div class="poi-popup-category">${category.name}</div>
                                            ${poi.description ? `<div class="poi-popup-description">${escapeHtml(poi.description.substring(0, 100))}${poi.description.length > 100 ? '...' : ''}</div>` : ''}
                                            <div class="poi-popup-order">Sıra: ${poi.order_in_route || index + 1}</div>
                                        </div>
                                    `);

                                    poiMarkersLayer.addLayer(marker);
                                }
                            });
                        }
                    }
                }

                // Add route layer to map if created
                if (routeLayer) {
                    routeLayer.bindPopup(`
                        <strong>${escapeHtml(route.name)}</strong><br>
                        ${ROUTE_TYPES[route.route_type]?.name || route.route_type}<br>
                        ${route.estimated_duration || 0} dakika
                    `);

                    routeLayers[rid] = routeLayer;
                    routeLayer.addTo(map);
                    console.log('Route layer added to map');

                    // Fit map to route and POIs
                    try {
                        const layers = [routeLayer];
                        if (poiMarkersLayer.getLayers().length > 0) {
                            layers.push(poiMarkersLayer);
                        }
                        const group = new L.featureGroup(layers);
                        map.fitBounds(group.getBounds(), { padding: [50, 50] });
                        console.log('Map fitted to route bounds');
                    } catch (e) {
                        console.warn('Failed to fit bounds:', e);
                    }
                } else {
                    console.warn('Could not create route layer');
                    showNotification('Rota haritada görüntülenemedi', 'warning');
                }

            } catch (error) {
                console.error('Error showing route on map:', error);
                showNotification('Rota görüntülenirken hata oluştu', 'error');
            }
        }

        // Render POI markers for a route on the map
        async function renderRoutePoisOnMap(routeId) {
            if (!poiMarkersLayer) return;
            try { poiMarkersLayer.clearLayers(); } catch (e) { }

            try {
                const resp = await fetch(`${apiBase}/admin/routes/${routeId}/pois`, { credentials: 'include' });
                if (!resp.ok) return;
                const data = await resp.json();
                const pois = Array.isArray(data?.pois) ? data.pois : (Array.isArray(data) ? data : []);
                // Sort by order_in_route if available
                pois.sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0));
                pois.forEach((p, idx) => {
                    const lat = Number(p.lat || p.latitude);
                    const lng = Number(p.lon || p.longitude);
                    if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
                    const marker = L.marker([lat, lng], {
                        title: p.name || `POI ${idx + 1}`
                    });
                    marker.bindPopup(`
                        <strong>${escapeHtml(p.name || 'POI')}</strong><br/>
                        ${p.category ? escapeHtml(p.category) : ''}<br/>
                        <small>Sıra: ${p.order_in_route || idx + 1}</small>
                    `);
                    poiMarkersLayer.addLayer(marker);
                });
            } catch (e) {
                console.warn('renderRoutePoisOnMap failed:', e);
            }
        }

        // Utility functions
        function getDifficultyStars(level) {
            return '⭐'.repeat(level || 0) + '☆'.repeat(5 - (level || 0));
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDate(dateString) {
            if (!dateString) return 'Bilinmiyor';
            return new Date(dateString).toLocaleDateString('tr-TR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function showLoading() {
            document.getElementById('routeListContainer').innerHTML = `
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            `;
        }

        function showError(message) {
            showNotification(message, 'error');
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="d-flex justify-content-between align-items-center">
                    <span>${message}</span>
                    <button type="button" class="btn-close btn-close-white" onclick="this.parentElement.parentElement.remove()"></button>
                </div>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }
        // Resizable Map Functionality
        function setupResizableMap() {
            const resizeHandle = document.getElementById('resizeHandle');
            const container = document.getElementById('routeContainer');
            let isResizing = false;
            let startX = 0;
            let startMapWidth = 600;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startMapWidth = getCurrentMapWidth();
                resizeHandle.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = startX - e.clientX; // Reversed because we're moving from right
                const newMapWidth = Math.max(400, Math.min(800, startMapWidth + deltaX));

                // Update grid template columns
                container.style.gridTemplateColumns = `380px 1fr ${newMapWidth}px`;

                // Update resize handle position
                resizeHandle.style.right = `${newMapWidth + 20}px`;

                // Invalidate map size
                if (map) {
                    setTimeout(() => map.invalidateSize(), 10);
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Final map size invalidation
                    if (map) {
                        setTimeout(() => map.invalidateSize(), 100);
                    }
                }
            });

            // Get current map width from computed styles
            function getCurrentMapWidth() {
                const computedStyle = window.getComputedStyle(container);
                const columns = computedStyle.gridTemplateColumns.split(' ');
                const mapColumn = columns[2];
                return parseInt(mapColumn) || 600;
            }
        }

        // Action handlers
        function refreshRoutes() {
            // Rate limiting kontrolü - Geliştirme için devre dışı
            // const now = Date.now();
            // if ((now - lastLoadTime) < minLoadInterval) {
            //     showNotification('Çok sık yenileme yapıyorsunuz, lütfen bekleyin', 'warning');
            //     return;
            // }
            loadRoutes();
        }
        function clearMapRoutes() {
            clearAllRoutesFromMap();
            // POI marker'larını da temizle
            if (poiMarkersLayer) {
                poiMarkersLayer.clearLayers();
            }
            // Seçili rotayı sıfırla
            currentRoute = null;
            // UI'dan seçimi kaldır
            document.querySelectorAll('.route-item').forEach(item => {
                item.classList.remove('selected');
            });
            // Workspace'i gizle
            hideWorkspace();
            showNotification('Harita temizlendi', 'success');
        }

        async function createAndEditRoute() {
            const routeData = {
                name: 'Yeni Rota',
                description: '',

                route_type: 'walking',
                difficulty_level: 1,
                is_active: true
            };

            try {
                const response = await fetch(`${apiBase}/admin/routes`, {

                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': window.csrfToken || ''
                    },
                    body: JSON.stringify(routeData)
                });

                if (response.ok) {
                    const result = await response.json();
                    await loadRoutes();
                    selectRoute(result.id);
                    editCurrentRoute();
                    showNotification('✅ Yeni rota oluşturuldu', 'success');
                } else {
                    const error = await response.json();
                    showNotification(`❌ Rota oluşturulamadı: ${error.message || 'Bilinmeyen hata'}`, 'error');
                }
            } catch (error) {
                console.error('Error creating route:', error);
                showNotification('❌ Rota oluşturulurken hata oluştu', 'error');
            }
        }

        // Map fullscreen functionality
        function toggleMapFullscreen() {
            const mapView = document.querySelector('.route-map-view');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const icon = fullscreenBtn.querySelector('i');

            if (mapView.classList.contains('fullscreen')) {
                // Exit fullscreen
                mapView.classList.remove('fullscreen');
                document.body.classList.remove('map-fullscreen');
                icon.className = 'fas fa-expand';
                fullscreenBtn.title = 'Tam Ekran';
            } else {
                // Enter fullscreen
                mapView.classList.add('fullscreen');
                document.body.classList.add('map-fullscreen');
                icon.className = 'fas fa-compress';
                fullscreenBtn.title = 'Tam Ekrandan Çık';
            }

            // Invalidate map size after transition
            setTimeout(() => {
                if (map) map.invalidateSize();
            }, 300);
        }

        // Map layer toggle functions
        function toggleMapLayer(layerType) {
            showNotification(`${layerType} katmanı özelliği yakında eklenecek`, 'info');
        }

        // Enhanced Media Management Functions
        
        // Show route media upload form
        function showRouteMediaUploadForm() {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'error');
                return;
            }

            const modalHtml = `
                <div class="modal fade" id="routeMediaUploadModal" tabindex="-1">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">
                                    <i class="fas fa-upload me-2"></i>
                                    Medya Dosyası Ekle - ${escapeHtml(currentRoute.name)}
                                </h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <form id="routeMediaUploadForm">
                                    <div class="mb-3">
                                        <label for="routeMediaFile" class="form-label">Medya Dosyası</label>
                                        <input type="file" class="form-control" id="routeMediaFile" accept="image/*,video/*,audio/*" required>
                                        <div class="form-text">
                                            Desteklenen formatlar: JPG, PNG, GIF, MP4, MP3, vb.<br>
                                            <small class="text-info">📸 Resimler isteğe bağlı olarak WebP formatına dönüştürülür (daha iyi sıkıştırma)</small>
                                        </div>
                                    </div>
                                    <div class="mb-3">
                                        <label for="routeMediaCaption" class="form-label">Açıklama (Opsiyonel)</label>
                                        <input type="text" class="form-control" id="routeMediaCaption" placeholder="Medya dosyası açıklaması">
                                    </div>
                                    <div class="mb-3">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="routeMediaPrimary">
                                            <label class="form-check-label" for="routeMediaPrimary">
                                                Ana görsel olarak ayarla
                                            </label>
                                        </div>
                                    </div>
                                    <div class="mb-3">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="routeMediaKeepOriginalModal">
                                            <label class="form-check-label" for="routeMediaKeepOriginalModal">
                                                Orijinal dosyayı (EXIF ile) yükle
                                            </label>
                                        </div>
                                        <div class="form-text">Seçilmezse görseller WebP formatına dönüştürülür.</div>
                                    </div>
                                </form>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">İptal</button>
                                <button type="button" class="btn btn-primary" onclick="uploadRouteMediaFromModal()">
                                    <i class="fas fa-upload me-1"></i>Yükle
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Remove existing modal if any
            const existingModal = document.getElementById('routeMediaUploadModal');
            if (existingModal) {
                existingModal.remove();
            }

            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('routeMediaUploadModal'));
            modal.show();
        }

        // Upload media from modal
        async function uploadRouteMediaFromModal() {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'error');
                return;
            }

            const fileInput = document.getElementById('routeMediaFile');
            const mediaCaption = document.getElementById('routeMediaCaption').value;
            const isPrimary = document.getElementById('routeMediaPrimary').checked;

            if (!fileInput.files || fileInput.files.length === 0) {
                showNotification('Lütfen bir medya dosyası seçin', 'error');
                return;
            }

            const file = fileInput.files[0];
            const filename = file.name.toLowerCase();

            // Auto-detect media type
            let mediaType = 'auto';
            if (filename.match(/\.(jpg|jpeg|png|gif|webp|bmp|tiff)$/)) {
                mediaType = 'image';
            } else if (filename.match(/\.(mp4|avi|mov|wmv|flv|webm|mkv|m4v)$/)) {
                mediaType = 'video';
            } else if (filename.match(/\.(mp3|wav|ogg|m4a|aac|flac)$/)) {
                mediaType = 'audio';
            } else if (filename.match(/\.(glb|gltf|obj|fbx|dae|ply|stl)$/)) {
                mediaType = 'model_3d';
            } else {
                showNotification('Dosya türü tespit edilemedi. Lütfen medya türünü manuel olarak seçin.', 'error');
                return;
            }

            // File size check
            const maxSize = getMediaMaxSize(mediaType) * 1024 * 1024;
            if (file.size > maxSize) {
                showNotification(`Dosya boyutu ${getMediaMaxSize(mediaType)}MB'dan küçük olmalıdır.\n\nSeçilen dosya: ${(file.size / 1024 / 1024).toFixed(1)}MB`, 'error');
                return;
            }

            let fileToUpload = file;
            const keepOriginal = document.getElementById('routeMediaKeepOriginalModal')?.checked;

            // Convert images to WebP format for better compression
            if (mediaType === 'image' && !filename.endsWith('.webp') && !keepOriginal) {
                try {
                    showNotification('Resim WebP formatına dönüştürülüyor...', 'info');
                    fileToUpload = await convertImageToWebP(file);
                    showNotification('Resim WebP formatına dönüştürüldü!', 'success');
                } catch (error) {
                    console.warn('WebP conversion failed, using original file:', error);
                    fileToUpload = file;
                    showNotification('WebP dönüştürme başarısız, orijinal dosya kullanılıyor', 'warning');
                }
            }

            const formData = new FormData();
            formData.append('file', fileToUpload);
            formData.append('caption', mediaCaption);
            formData.append('is_primary', isPrimary);

            try {
                const response = await fetch(`${apiBase}/admin/routes/${getRouteId(currentRoute)}/media`, {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Medya yükleme başarısız');
                }

                const result = await response.json();

                if (result.media && result.media.compression_ratio && result.media.compression_ratio !== "0%") {
                    showNotification(`${getMediaTypeIcon(mediaType)} ${mediaType.toUpperCase()} başarıyla yüklendi!\n📦 Boyut azalması: ${result.media.compression_ratio}`, 'success');
                } else {
                    showNotification(`${getMediaTypeIcon(mediaType)} ${mediaType.toUpperCase()} başarıyla yüklendi!`, 'success');
                }

                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('routeMediaUploadModal'));
                if (modal) modal.hide();

                // Clear form fields
                fileInput.value = '';
                document.getElementById('routeMediaCaption').value = '';
                document.getElementById('routeMediaPrimary').checked = false;

                // Wait a moment for the server to process the upload
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Reload media
                await loadRouteMediaForEdit(getRouteId(currentRoute));

                // For images, automatically try to extract EXIF location data
                if (mediaType === 'image') {
                    try {
                        showNotification('📸 EXIF konum bilgisi aranıyor...', 'info');
                        
                        // Get the uploaded filename (might be different from original due to WebP conversion)
                        const uploadedFilename = result.media?.filename || fileToUpload.name;
                        
                        // Try to automatically extract location from EXIF
                        const locationResponse = await fetch(`${apiBase}/admin/routes/${getRouteId(currentRoute)}/media/${uploadedFilename}/location/auto`, {
                            method: 'POST',
                            credentials: 'include'
                        });

                        if (locationResponse.ok) {
                            const locationData = await locationResponse.json();
                            if (locationData.success && locationData.media) {
                                const lat = parseFloat(locationData.media.lat ?? locationData.media.latitude);
                                const lng = parseFloat(locationData.media.lng ?? locationData.media.longitude);
                                
                                if (isFinite(lat) && isFinite(lng)) {
                                    showNotification(`🎯 EXIF konum bilgisi otomatik olarak eklendi!\n📍 Konum: ${lat.toFixed(6)}, ${lng.toFixed(6)}`, 'success');
                                    
                                    // Refresh media display to show the new location
                                    await loadRouteMediaForEdit(getRouteId(currentRoute));
                                    
                                    // Update map markers
                                    refreshPhotoLocationMarkers();
                                    
                                    // Update elevation chart
                                    if (window.routeElevationChart) {
                                        refreshPhotoLocationMarkers();
                                    }
                                } else {
                                    showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi bulunamadı', 'info');
                                }
                            } else {
                                showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi bulunamadı', 'info');
                            }
                        } else {
                            showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi bulunamadı', 'info');
                        }
                    } catch (exifError) {
                        console.warn('EXIF extraction failed:', exifError);
                        showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi çıkarılamadı', 'info');
                    }
                }

            } catch (error) {
                console.error('Media upload error:', error);
                showNotification('Medya yükleme hatası: ' + error.message, 'error');
            }
        }

        // Convert image to WebP format
        async function convertImageToWebP(file) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // Calculate new dimensions while maintaining aspect ratio
                    const maxWidth = 1920;
                    const maxHeight = 1080;
                    let { width, height } = img;
                    
                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width *= ratio;
                        height *= ratio;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw image with white background for transparent images
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to WebP with quality 0.85
                    canvas.toBlob((blob) => {
                        if (blob) {
                            // Create new file with WebP extension
                            const webpFile = new File([blob], file.name.replace(/\.[^/.]+$/, '.webp'), {
                                type: 'image/webp',
                                lastModified: Date.now()
                            });
                            resolve(webpFile);
                        } else {
                            reject(new Error('WebP conversion failed'));
                        }
                    }, 'image/webp', 0.85);
                };
                
                img.onerror = () => reject(new Error('Image loading failed'));
                img.src = URL.createObjectURL(file);
            });
        }

        // Convert existing image URL to WebP format
        async function convertImageUrlToWebP(imageUrl, filename) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    // Calculate new dimensions while maintaining aspect ratio
                    const maxWidth = 1920;
                    const maxHeight = 1080;
                    let { width, height } = img;
                    
                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width *= ratio;
                        height *= ratio;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw image with white background for transparent images
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to WebP with quality 0.85
                    canvas.toBlob((blob) => {
                        if (blob) {
                            // Create new file with WebP extension
                            const webpFile = new File([blob], filename.replace(/\.[^/.]+$/, '.webp'), {
                                type: 'image/webp',
                                lastModified: Date.now()
                            });
                            resolve(webpFile);
                        } else {
                            reject(new Error('WebP conversion failed'));
                        }
                    }, 'image/webp', 0.85);
                };
                
                img.onerror = () => reject(new Error('Image loading failed'));
                img.src = imageUrl;
            });
        }

        // Convert existing image to WebP and replace it
        async function convertExistingImageToWebP(filename, imagePath) {
            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            if (!routeId) {
                showNotification('Rota ID bulunamadı', 'error');
                return;
            }

            if (!confirm(`"${filename}" dosyasını WebP formatına dönüştürmek istediğinizden emin misiniz?\n\nBu işlem orijinal dosya ile değiştirilecektir.`)) {
                return;
            }

            try {
                showNotification('Resim WebP formatına dönüştürülüyor...', 'info');
                
                // Convert the image to WebP
                const webpFile = await convertImageUrlToWebP(imagePath, filename);
                
                // Create form data for upload
                const formData = new FormData();
                formData.append('file', webpFile);
                formData.append('caption', `WebP dönüştürülmüş: ${filename}`);
                
                // Try to replace existing file if supported
                try {
                    formData.append('replace_existing', 'true');
                } catch (e) {
                    // Some servers might not support this parameter
                    console.log('replace_existing parameter not supported');
                }

                // Upload the converted WebP file
                const response = await fetch(`${apiBase}/admin/routes/${routeId}/media`, {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });

                if (response.ok) {
                    showNotification(`"${filename}" başarıyla WebP formatına dönüştürüldü!`, 'success');
                    
                    // Wait a moment for the server to process the file
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Reload media to show the updated file
                    console.log('Reloading media after WebP conversion...');
                    await loadRouteMediaForEdit(routeId);
                    
                    // Additional verification - check if the WebP file is now visible
                    setTimeout(async () => {
                        try {
                            const verifyResponse = await fetch(`${apiBase}/admin/routes/${routeId}/media`, {
                                credentials: 'include'
                            });
                            if (verifyResponse.ok) {
                                const verifyData = await verifyResponse.json();
                                console.log('Verification - Media after WebP conversion:', verifyData);
                                
                                // Check if WebP file exists
                                const webpFile = Array.isArray(verifyData) ? verifyData : (verifyData.media || []);
                                const hasWebP = webpFile.some(m => 
                                    (m.filename || m.name || '').toLowerCase().endsWith('.webp') ||
                                    (m.path || m.file_path || '').toLowerCase().endsWith('.webp')
                                );
                                
                                if (hasWebP) {
                                    console.log('✅ WebP file successfully verified in media list');
                                } else {
                                    console.warn('⚠️ WebP file not found in media list after conversion');
                                }
                            }
                        } catch (verifyError) {
                            console.warn('Verification failed:', verifyError);
                        }
                    }, 2000);
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'WebP dönüştürme başarısız');
                }
            } catch (error) {
                console.error('WebP conversion error:', error);
                showNotification('WebP dönüştürme hatası: ' + error.message, 'error');
            }
        }

        // Debug media display issues
        function debugMediaDisplay(routeId) {
            console.log('🔍 Debugging media display for route:', routeId);
            
            // Check if container exists
            const container = document.getElementById('routeCurrentMedia');
            console.log('Media container found:', !!container);
            if (container) {
                console.log('Container innerHTML length:', container.innerHTML.length);
                console.log('Container classes:', container.className);
            }
            
            // Check if route is selected
            console.log('Current route:', currentRoute);
            console.log('Current route ID:', getRouteId(currentRoute));
            
            // Check if media loading function exists
            console.log('loadRouteMediaForEdit function exists:', typeof loadRouteMediaForEdit === 'function');
            
            // Try to manually trigger media loading
            if (typeof loadRouteMediaForEdit === 'function' && routeId) {
                console.log('Manually triggering media loading...');
                loadRouteMediaForEdit(routeId);
            }
        }

        // Test API endpoints for debugging
        async function testMediaAPIEndpoints(routeId, filename) {
            if (!routeId || !filename) {
                showNotification('Rota ID ve dosya adı gerekli', 'error');
                return;
            }

            const endpoints = [
                { method: 'DELETE', url: `${apiBase}/admin/routes/${routeId}/media/${filename}/location`, description: 'Location DELETE endpoint' },
                { method: 'PATCH', url: `${apiBase}/admin/routes/${routeId}/media/${filename}`, description: 'Media PATCH endpoint' },
                { method: 'PUT', url: `${apiBase}/admin/routes/${routeId}/media/${filename}`, description: 'Media PUT endpoint' }
            ];

            showNotification('API endpoint testleri başlatılıyor...', 'info');

            for (const endpoint of endpoints) {
                try {
                    const response = await fetch(endpoint.url, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': csrfToken || ''
                        },
                        credentials: 'include'
                    });

                    console.log(`${endpoint.description}: ${response.status} ${response.statusText}`);
                    
                    if (response.status === 405) {
                        console.log(`${endpoint.description} - Method Not Allowed`);
                    } else if (response.status === 404) {
                        console.log(`${endpoint.description} - Not Found`);
                    } else if (response.status >= 500) {
                        console.error(`${endpoint.description} - Server Error: ${response.status}`);
                    }
                } catch (error) {
                    console.error(`${endpoint.description} - Network Error:`, error);
                }
            }

            showNotification('API endpoint testleri tamamlandı. Console\'u kontrol edin.', 'info');
        }

        // Enhanced error logging for location operations
        function logLocationOperation(operation, filename, routeId, details = {}) {
            const logData = {
                timestamp: new Date().toISOString(),
                operation,
                filename,
                routeId,
                apiBase,
                csrfToken: csrfToken ? 'present' : 'missing',
                userAgent: navigator.userAgent,
                ...details
            };
            
            console.group(`🔍 Location Operation: ${operation}`);
            console.log('Details:', logData);
            console.groupEnd();
            
            // Store in localStorage for debugging
            const logs = JSON.parse(localStorage.getItem('locationOperationLogs') || '[]');
            logs.push(logData);
            if (logs.length > 100) logs.shift(); // Keep only last 100 logs
            localStorage.setItem('locationOperationLogs', JSON.stringify(logs));
        }

        // Refresh route media
        async function refreshRouteMedia() {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'error');
                return;
            }

            try {
                await loadRouteMediaForEdit(getRouteId(currentRoute));
                showNotification('Medya listesi yenilendi', 'success');
            } catch (error) {
                console.error('Media refresh error:', error);
                showNotification('Medya yenilenirken hata oluştu: ' + error.message, 'error');
            }
        }
        async function uploadRouteMedia() {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'error');
                return;
            }

            const fileInput = document.getElementById('routeMediaFile');
            const mediaTypeSelect = document.getElementById('routeMediaType');
            const mediaCaption = document.getElementById('routeMediaCaption').value;
            const isPrimary = document.getElementById('routeMediaPrimary').checked;

            if (!fileInput.files || fileInput.files.length === 0) {
                showNotification('Lütfen bir medya dosyası seçin', 'error');
                return;
            }

            const file = fileInput.files[0];
            const filename = file.name.toLowerCase();

            // Auto-detect media type
            let mediaType = mediaTypeSelect.value;
            if (mediaType === 'auto') {
                if (filename.match(/\.(jpg|jpeg|png|gif|webp|bmp|tiff)$/)) {
                    mediaType = 'image';
                } else if (filename.match(/\.(mp4|avi|mov|wmv|flv|webm|mkv|m4v)$/)) {
                    mediaType = 'video';
                } else if (filename.match(/\.(mp3|wav|ogg|m4a|aac|flac)$/)) {
                    mediaType = 'audio';
                } else if (filename.match(/\.(glb|gltf|obj|fbx|dae|ply|stl)$/)) {
                    mediaType = 'model_3d';
                } else {
                    showNotification('Dosya türü tespit edilemedi. Lütfen medya türünü manuel olarak seçin.', 'error');
                    return;
                }
            }

            // File size check
            const maxSize = getMediaMaxSize(mediaType) * 1024 * 1024;
            if (file.size > maxSize) {
                showNotification(`Dosya boyutu ${getMediaMaxSize(mediaType)}MB'dan küçük olmalıdır.\n\nSeçilen dosya: ${(file.size / 1024 / 1024).toFixed(1)}MB`, 'error');
                return;
            }

            let fileToUpload = file;
            const keepOriginal = document.getElementById('routeMediaKeepOriginal')?.checked;

            if (mediaType === 'image' && !filename.endsWith('.webp') && !keepOriginal) {
                try {
                    showNotification('Resim WebP formatına dönüştürülüyor...', 'info');
                    fileToUpload = await convertImageToWebP(file);
                    showNotification('Resim WebP formatına dönüştürüldü!', 'success');
                } catch (error) {
                    console.warn('WebP conversion failed, using original file:', error);
                    fileToUpload = file;
                    showNotification('WebP dönüştürme başarısız, orijinal dosya kullanılıyor', 'warning');
                }
            }

            const formData = new FormData();
            // Backend API expects the uploaded file under the 'file' field name
            // Using a different key results in the server thinking no file was provided
            // and returning a 404/HTML error page which then breaks JSON parsing
            formData.append('file', fileToUpload);
            formData.append('caption', mediaCaption);
            formData.append('is_primary', isPrimary);

            try {
                const response = await fetch(`${apiBase}/admin/routes/${getRouteId(currentRoute)}/media`, {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Medya yükleme başarısız');
                }

                const result = await response.json();

                if (result.media && result.media.compression_ratio && result.media.compression_ratio !== "0%") {
                    showNotification(`${getMediaTypeIcon(mediaType)} ${mediaType.toUpperCase()} başarıyla yüklendi!\n📦 Boyut azalması: ${result.media.compression_ratio}`, 'success');
                } else {
                    showNotification(`${getMediaTypeIcon(mediaType)} ${mediaType.toUpperCase()} başarıyla yüklendi!`, 'success');
                }

                // Clear form fields
                fileInput.value = '';
                document.getElementById('routeMediaCaption').value = '';
                document.getElementById('routeMediaPrimary').checked = false;
                mediaTypeSelect.value = 'auto';

                // Wait a moment for the server to process the upload
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Reload media with retry logic
                let retryCount = 0;
                const maxRetries = 5;
                
                while (retryCount < maxRetries) {
                    try {
                        console.log(`Reloading media, attempt ${retryCount + 1}`);
                        await loadRouteMediaForEdit(getRouteId(currentRoute));
                        console.log('Media reload successful on attempt', retryCount + 1);
                        break;
                    } catch (error) {
                        retryCount++;
                        console.warn(`Media reload attempt ${retryCount} failed:`, error);
                        if (retryCount < maxRetries) {
                            await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                        } else {
                            console.error('All media reload attempts failed');
                        }
                    }
                }

                // Also try to reload via the old function if it exists
                if (typeof loadRouteMedia === 'function') {
                    try {
                        await loadRouteMedia(getRouteId(currentRoute));
                    } catch (e) {
                        console.warn('Old loadRouteMedia failed:', e);
                    }
                }

                // For images, automatically try to extract EXIF location data
                if (mediaType === 'image') {
                    try {
                        showNotification('📸 EXIF konum bilgisi aranıyor...', 'info');
                        
                        // Get the uploaded filename (might be different from original due to WebP conversion)
                        const uploadedFilename = result.media?.filename || fileToUpload.name;
                        
                        // Try to automatically extract location from EXIF
                        const locationResponse = await fetch(`${apiBase}/admin/routes/${getRouteId(currentRoute)}/media/${uploadedFilename}/location/auto`, {
                            method: 'POST',
                            credentials: 'include'
                        });

                        if (locationResponse.ok) {
                            const locationData = await locationResponse.json();
                            if (locationData.success && locationData.media) {
                                const lat = parseFloat(locationData.media.lat ?? locationData.media.latitude);
                                const lng = parseFloat(locationData.media.lng ?? locationData.media.longitude);
                                
                                if (isFinite(lat) && isFinite(lng)) {
                                    showNotification(`🎯 EXIF konum bilgisi otomatik olarak eklendi!\n📍 Konum: ${lat.toFixed(6)}, ${lng.toFixed(6)}`, 'success');
                                    
                                    // Refresh media display to show the new location
                                    await loadRouteMediaForEdit(getRouteId(currentRoute));
                                    
                                    // Update map markers
                                    refreshPhotoLocationMarkers();
                                    
                                    // Update elevation chart
                                    if (window.routeElevationChart) {
                                        refreshPhotoLocationMarkers();
                                    }
                                } else {
                                    showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi bulunamadı', 'info');
                                }
                            } else {
                                showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi bulunamadı', 'info');
                            }
                        } else {
                            showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi bulunamadı', 'info');
                        }
                    } catch (exifError) {
                        console.warn('EXIF extraction failed:', exifError);
                        showNotification('📸 Fotoğraf yüklendi ancak EXIF konum bilgisi çıkarılamadı', 'info');
                    }
                }

            } catch (error) {
                console.error('Media upload error:', error);
                showNotification('Medya yükleme hatası: ' + error.message, 'error');
            }
        }

        function getMediaTypeIcon(mediaType) {
            const icons = {
                'image': '📸',
                'video': '🎥',
                'audio': '🎵',
                'model_3d': '🧊',
                'unknown': '📄'
            };
            return icons[mediaType] || '📄';
        }

        function getMediaMaxSize(mediaType) {
            const sizes = {
                'image': 15,
                'video': 100,
                'audio': 50,
                'model_3d': 50
            };
            return sizes[mediaType] || 15;
        }

        async function loadRouteMediaForEdit(routeId) {
            if (!routeId) {
                console.warn('loadRouteMediaForEdit: No routeId provided');
                return;
            }

            console.log('Loading media for route:', routeId);

            try {
                // Ensure container exists and show loading state
                let container = document.getElementById('routeCurrentMedia');
                if (!container) {
                    console.warn('Media container not found, waiting for DOM...');
                    // Wait a bit more for DOM to be ready
                    await new Promise(resolve => setTimeout(resolve, 500));
                    container = document.getElementById('routeCurrentMedia');
                    if (!container) {
                        console.error('Media container still not found after delay');
                        
                        // Try to find the container in the edit form
                        const editForm = document.getElementById('routeEditForm');
                        if (editForm) {
                            console.log('Edit form found, looking for media container...');
                            // Look for any element with 'media' in the ID
                            const mediaElements = editForm.querySelectorAll('[id*="media"]');
                            console.log('Found media elements:', mediaElements);
                            
                            if (mediaElements.length > 0) {
                                container = mediaElements[0];
                                console.log('Using found media container:', container);
                            }
                        }
                        
                        if (!container) {
                            console.error('Media container could not be found or created');
                            return;
                        }
                    }
                }

                // Show loading state
                container.innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Medya dosyaları yükleniyor...</p></div>';

                const response = await fetch(`${apiBase}/admin/routes/${routeId}/media`, {
                    credentials: 'include'
                });
                
                console.log('Media API response status:', response.status);

                if (!response.ok) {
                    console.error('Media API error:', response.status, response.statusText);
                    container.innerHTML = '<div class="text-center text-muted py-3">Medya bilgileri yüklenemedi. HTTP: ' + response.status + '</div>';
                    return;
                }

                const data = await response.json();
                console.log('Media API response data:', data);
                console.log('Media API response data type:', typeof data);
                console.log('Media API response data keys:', Object.keys(data || {}));
                if (Array.isArray(data)) {
                    console.log('Media API returned array with', data.length, 'items');
                }
                
                // Handle different possible response formats
                let mediaFiles = [];
                if (Array.isArray(data)) {
                    mediaFiles = data;
                } else if (Array.isArray(data.media)) {
                    mediaFiles = data.media;
                } else if (Array.isArray(data.files)) {
                    mediaFiles = data.files;
                } else if (data && typeof data === 'object') {
                    // Try to find any array in the response
                    Object.values(data).forEach(value => {
                        if (Array.isArray(value)) {
                            mediaFiles = value;
                        }
                    });
                }

                // Ensure all media items have proper media_type set
                mediaFiles.forEach(media => {
                    if (media && !media.media_type) {
                        // Try to determine media type from filename or path
                        const filename = media.filename || media.name || '';
                        const filePath = media.path || media.file_path || '';
                        
                        if (filename || filePath) {
                            const checkPath = filename || filePath;
                            const lowerPath = checkPath.toLowerCase();
                            
                            if (lowerPath.endsWith('.webp') || lowerPath.endsWith('.jpg') || lowerPath.endsWith('.jpeg') || 
                                lowerPath.endsWith('.png') || lowerPath.endsWith('.gif') || lowerPath.endsWith('.bmp') || 
                                lowerPath.endsWith('.tiff')) {
                                media.media_type = 'image';
                                console.log('Set media_type to image for:', checkPath);
                            } else if (lowerPath.endsWith('.mp4') || lowerPath.endsWith('.avi') || lowerPath.endsWith('.mov') || 
                                     lowerPath.endsWith('.wmv') || lowerPath.endsWith('.flv') || lowerPath.endsWith('.webm') || 
                                     lowerPath.endsWith('.mkv') || lowerPath.endsWith('.m4v')) {
                                media.media_type = 'video';
                                console.log('Set media_type to video for:', checkPath);
                            } else if (lowerPath.endsWith('.mp3') || lowerPath.endsWith('.wav') || lowerPath.endsWith('.ogg') || 
                                     lowerPath.endsWith('.m4a') || lowerPath.endsWith('.aac') || lowerPath.endsWith('.flac')) {
                                media.media_type = 'audio';
                                console.log('Set media_type to audio for:', checkPath);
                            } else if (lowerPath.endsWith('.glb') || lowerPath.endsWith('.gltf') || lowerPath.endsWith('.obj') || 
                                     lowerPath.endsWith('.fbx') || lowerPath.endsWith('.dae') || lowerPath.endsWith('.ply') || 
                                     lowerPath.endsWith('.stl')) {
                                media.media_type = 'model_3d';
                                console.log('Set media_type to model_3d for:', checkPath);
                            } else {
                                media.media_type = 'unknown';
                                console.log('Could not determine media_type for:', checkPath);
                            }
                        }
                    }
                });

                console.log('Processed media files:', mediaFiles);
                console.log('Processed media files count:', mediaFiles.length);
                if (mediaFiles.length > 0) {
                    console.log('First media file structure:', mediaFiles[0]);
                }

                // Update edit form current media
                displayRouteCurrentMedia(mediaFiles, routeId);

                // Update map and elevation chart with media locations
                try {
                    const located = mediaFiles.filter(m => (m.lat || m.latitude) && (m.lng || m.longitude || m.lon));
                    if (located.length > 0) {
                        // Add markers
                        const typeLabels = { image: 'Fotoğraf', video: 'Video', audio: 'Ses', model_3d: '3D Model', unknown: 'Medya' };
                        located.forEach(m => {
                            const lat = parseFloat(m.lat ?? m.latitude);
                            const lng = parseFloat(m.lng ?? m.longitude ?? m.lon);
                            if (!isFinite(lat) || !isFinite(lng)) return;
                            const label = typeLabels[m.media_type] || 'Medya';
                            let preview = '';
                            const mediaPath = m.preview_path || m.thumbnail_path || m.file_path;
                            if (mediaPath) {
                                if (m.media_type === 'image') {
                                    preview = `<div style=\"margin-top:8px\"><img src='/${mediaPath}' alt='media' style='width:100%;border-radius:6px;'/></div>`;
                                } else if (m.media_type === 'video') {
                                    preview = `<div style=\"margin-top:8px\"><video src='/${mediaPath}' controls style='width:100%;border-radius:6px;max-height:200px'></video></div>`;
                                } else if (m.media_type === 'audio') {
                                    preview = `<div style=\"margin-top:8px\"><audio controls style='width:100%'><source src='/${mediaPath}'></audio></div>`;
                                }
                            }
                            const mk = L.marker([lat, lng], { icon: getMediaMarkerIcon(m.media_type) })
                                .bindPopup(`<div style=\"min-width:180px\"><strong>${label}</strong>${m.caption ? `<div style=\\\"margin-top:4px;color:#666\\\">${m.caption}</div>`: ''}${preview}</div>`)
                                .addTo(map);
                            poiMarkersLayer.addLayer(mk);
                        });
                        if (window.routeElevationChart) {
                            window.routeElevationChart.setMediaMarkers(located);
                        }
                    } else if (window.routeElevationChart) {
                        window.routeElevationChart.setMediaMarkers([]);
                    }
                } catch (e) {
                    console.warn('Medya konumları haritaya eklenemedi:', e);
                }

            } catch (error) {
                console.error('Error loading route media:', error);
                const container = document.getElementById('routeCurrentMedia');
                if (container) {
                    container.innerHTML = '<div class="text-center text-danger py-3">Medya yüklenirken hata oluştu: ' + error.message + '</div>';
                }
            }
        }

        function displayRouteCurrentMedia(mediaFiles, routeId) {
            const container = document.getElementById('routeCurrentMedia');
            if (!container) {
                console.error('Media container not found in displayRouteCurrentMedia');
                return;
            }

            console.log('Displaying media files:', mediaFiles);

            if (!Array.isArray(mediaFiles) || mediaFiles.length === 0) {
                container.innerHTML = '<div class="text-center text-muted py-3">Henüz medya dosyası eklenmemiş.</div>';
                return;
            }

            // Group media by type
            const groupedMedia = {};
            mediaFiles.forEach(media => {
                if (!media) return; // Skip null/undefined items
                
                // Enhanced media type detection - ensure WebP files are treated as images
                let type = media.media_type || media.type || 'unknown';
                
                // If media_type is not set but filename suggests it's an image, set it to 'image'
                if (type === 'unknown' && media.filename) {
                    const filename = media.filename.toLowerCase();
                    if (filename.endsWith('.webp') || filename.endsWith('.jpg') || filename.endsWith('.jpeg') || 
                        filename.endsWith('.png') || filename.endsWith('.gif') || filename.endsWith('.bmp') || 
                        filename.endsWith('.tiff')) {
                        type = 'image';
                        // Update the media object to ensure consistency
                        media.media_type = 'image';
                    }
                }
                
                // Also check the file path if filename is not available
                if (type === 'unknown' && (media.path || media.file_path)) {
                    const filePath = (media.path || media.file_path).toLowerCase();
                    if (filePath.endsWith('.webp') || filePath.endsWith('.jpg') || filePath.endsWith('.jpeg') || 
                        filePath.endsWith('.png') || filePath.endsWith('.gif') || filePath.endsWith('.bmp') || 
                        filePath.endsWith('.tiff')) {
                        type = 'image';
                        media.media_type = 'image';
                    }
                }
                
                if (!groupedMedia[type]) groupedMedia[type] = [];
                groupedMedia[type].push(media);
            });

            console.log('Grouped media:', groupedMedia);

            let mediaHtml = '';

            Object.keys(groupedMedia).forEach(mediaType => {
                const typeIcon = getMediaTypeIcon(mediaType);
                const typeLabel = {
                    'image': 'Görseller',
                    'video': 'Videolar',
                    'audio': 'Ses Dosyaları',
                    'model_3d': '3D Modeller',
                    'unknown': 'Diğer'
                }[mediaType] || mediaType.toUpperCase();

                mediaHtml += `
                    <div class="media-type-section">
                        <h6 class="media-type-title">${typeIcon} ${typeLabel} (${groupedMedia[mediaType].length})</h6>
                        <div class="current-media-grid">
                `;

                groupedMedia[mediaType].forEach(media => {
                    if (!media) return;
                    
                    // Handle different path field names and ensure proper path construction
                    const rawPath = media.path || media.file_path || media.url || '';
                    const filename = media.filename || media.name || rawPath.split('/').pop() || 'Unknown file';
                    
                    // Try multiple thumbnail paths in order of preference
                    let previewPath = '';
                    if (media.thumbnail_path) {
                        previewPath = media.thumbnail_path.startsWith('/') ? media.thumbnail_path : `/${media.thumbnail_path}`;
                    } else if (media.preview_path) {
                        previewPath = media.preview_path.startsWith('/') ? media.preview_path : `/${media.preview_path}`;
                    } else if (media.thumb_path) {
                        previewPath = media.thumb_path.startsWith('/') ? media.thumb_path : `/${media.thumb_path}`;
                    } else if (rawPath) {
                        // Fallback to original path if no thumbnail
                        previewPath = rawPath.startsWith('/') ? rawPath : `/${rawPath}`;
                    }
                    
                    console.log('Media thumbnail paths:', {
                        filename,
                        thumbnail_path: media.thumbnail_path,
                        preview_path: media.preview_path,
                        thumb_path: media.thumb_path,
                        rawPath,
                        finalPreviewPath: previewPath,
                        media_type: media.media_type
                    });
                    
                    // Enhanced image detection - include WebP files
                    const isImage = mediaType === 'image' || 
                                  (media.media_type === 'image') || 
                                  filename.toLowerCase().endsWith('.webp') ||
                                  filename.toLowerCase().endsWith('.jpg') ||
                                  filename.toLowerCase().endsWith('.jpeg') ||
                                  filename.toLowerCase().endsWith('.png') ||
                                  filename.toLowerCase().endsWith('.gif') ||
                                  filename.toLowerCase().endsWith('.bmp') ||
                                  filename.toLowerCase().endsWith('.tiff');
                    
                    // Check if media has location coordinates
                    const hasLocation = (media.lat || media.latitude) && (media.lng || media.longitude || media.lon);
                    const lat = parseFloat(media.lat ?? media.latitude);
                    const lng = parseFloat(media.lng ?? media.longitude ?? media.lon);

                    console.log('Processing media item:', { 
                        media, 
                        rawPath, 
                        filename, 
                        previewPath, 
                        isImage, 
                        hasLocation, 
                        lat, 
                        lng,
                        media_type: media.media_type
                    });

                    // Ensure rawPath is properly formatted for modal
                    const modalPath = rawPath.startsWith('/') ? rawPath : `/${rawPath}`;

                    mediaHtml += `
                        <div class="media-item-card ${hasLocation ? 'has-location' : ''}" data-media-id="${filename}" data-lat="${lat || ''}" data-lng="${lng || ''}">
                            <button class="media-delete-btn" onclick="deleteRouteMediaFile('${routeId}', '${filename}')" title="Sil">
                                <i class="fas fa-times"></i>
                            </button>

                            ${isImage && previewPath ?
                            `<img src="${previewPath}" class="media-preview" alt="${filename}"
                                      onclick="showRouteMediaModal('${modalPath}', '${filename}', '${mediaType}')"
                                      onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                      style="display: block;">` : ''
                        }
                            
                            ${(!isImage || !previewPath) ?
                            `<div class="media-placeholder" onclick="showRouteMediaModal('${modalPath}', '${filename}', '${mediaType}')" style="display: ${isImage && previewPath ? 'none' : 'flex'};">
                                    ${getMediaTypeIcon(mediaType)}
                                    <div class="media-format">${filename.split('.').pop()?.toUpperCase() || ''}</div>
                                </div>` : ''
                        }

                            <div class="media-type-badge">${getMediaTypeIcon(mediaType)}</div>

                            <div class="media-item-info">
                                <div class="media-item-name">${filename || ''}</div>
                                <div class="media-item-size">${media.file_size ? (media.file_size / 1024).toFixed(0) + 'KB' : ''}</div>
                                ${media.compression_ratio && media.compression_ratio !== "0%" ? 
                                    `<div class="media-compression">📦 ${media.compression_ratio}</div>` : ''}
                                
                                <!-- Location Information -->
                                <div class="media-location-info">
                                    ${hasLocation ? 
                                        `<div class="location-badge location-set">
                                            <i class="fas fa-map-marker-alt"></i>
                                            <span>${lat.toFixed(6)}, ${lng.toFixed(6)}</span>
                                            <div class="location-actions">
                                                <button class="btn-location-edit" onclick="editPhotoLocation('${filename}', ${lat}, ${lng})" title="Konumu Düzenle">
                                                    <i class="fas fa-edit"></i>
                                                </button>
                                                <button class="btn-location-remove" onclick="removePhotoLocation('${filename}')" title="Konumu Kaldır">
                                                    <i class="fas fa-times"></i>
                                                </button>
                                            </div>
                                            <div class="location-source-info">
                                                <small class="text-success">
                                                    <i class="fas fa-check-circle"></i> Konum otomatik olarak EXIF'ten çıkarıldı
                                                </small>
                                            </div>
                                        </div>` :
                                        `<div class="location-badge location-missing">
                                            <i class="fas fa-map-marker-alt text-muted"></i>
                                            <span class="text-muted">Konum yok</span>
                                            <div class="location-actions">
                                                <button class="btn-location-add" onclick="addPhotoLocation('${filename}')" title="EXIF'ten Konum Çıkar">
                                                    <i class="fas fa-magic"></i>
                                                </button>
                                                <button class="btn-location-edit" onclick="addPhotoLocation('${filename}')" title="Manuel Konum Ekle">
                                                    <i class="fas fa-plus"></i>
                                                </button>
                                            </div>
                                            <div class="location-source-info">
                                                <small class="text-muted">
                                                    <i class="fas fa-info-circle"></i> EXIF konum bilgisi yok veya çıkarılamadı
                                                </small>
                                            </div>
                                        </div>`
                                    }
                                    
                                    <!-- WebP Conversion Button for Images (only show for non-WebP images) -->
                                    ${isImage && !filename.toLowerCase().endsWith('.webp') ? 
                                        `<div class="webp-conversion-actions mt-2">
                                            <button class="btn btn-sm btn-outline-info" onclick="convertExistingImageToWebP('${filename}', '${rawPath}')" title="WebP formatına dönüştür">
                                                <i class="fas fa-compress"></i> WebP'ye Dönüştür
                                            </button>
                                        </div>` : ''
                                    }
                                    
                                    <!-- Debug Button for API Testing -->
                                    <div class="debug-actions mt-1">
                                        <button class="btn btn-sm btn-outline-secondary" onclick="testMediaAPIEndpoints('${routeId}', '${filename}')" title="API endpoint testleri">
                                            <i class="fas fa-bug"></i> API Test
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                mediaHtml += `
                        </div>
                    </div>
                `;
            });

            container.innerHTML = mediaHtml;
            console.log('Media display completed');
        }

        async function deleteRouteMediaFile(routeId, filename) {
            if (!confirm(`'${filename}' dosyasını silmek istediğinizden emin misiniz?`)) {
                return;
            }

            try {
                const response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Dosya silinemedi');
                }

                showNotification('Medya dosyası başarıyla silindi', 'success');

                // Reload media
                await loadRouteMediaForEdit(routeId);

            } catch (error) {
                console.error('Media delete error:', error);
                showNotification('Medya silme hatası: ' + error.message, 'error');
            }
        }
        function showRouteMediaModal(mediaPath, filename, mediaType) {
            const modal = document.createElement('div');
            modal.className = 'modal fade';

            let modalContent = '';
            if (mediaType === 'image') {
                modalContent = `<img src="${mediaPath}" class="img-fluid rounded-3 shadow-lg" alt="${filename}" style="max-height: 70vh;">`;
            } else if (mediaType === 'video') {
                modalContent = `
                    <video controls class="w-100 rounded-3 shadow-lg" style="max-height: 70vh;">
                        <source src="${mediaPath}" type="video/mp4">
                        Tarayıcınız video oynatmayı desteklemiyor.
                    </video>`;
            } else if (mediaType === 'audio') {
                modalContent = `
                    <div class="text-center p-4">
                        <i class="fas fa-music fa-3x text-primary mb-3"></i>
                        <h5>${filename}</h5>
                        <audio controls class="w-100 mt-3">
                            <source src="${mediaPath}">
                            Tarayıcınız ses oynatmayı desteklemiyor.
                        </audio>
                    </div>`;
            } else if (mediaType === 'model_3d') {
                modalContent = `
                    <div class="text-center p-4">
                        <i class="fas fa-cube fa-3x text-primary mb-3"></i>
                        <h5>${filename}</h5>
                        <p class="text-muted">3D model dosyası - indirip uygun bir uygulamada görüntüleyebilirsiniz.</p>
                    </div>`;
            } else {
                modalContent = `
                    <div class="text-center p-4">
                        <i class="fas fa-file fa-3x text-primary mb-3"></i>
                        <h5>${filename}</h5>
                        <p class="text-muted">Medya dosyası</p>
                    </div>`;
            }

            modal.innerHTML = `
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title fw-bold"><i class="fas fa-file me-2"></i>${filename}</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body text-center p-4">
                            ${modalContent}
                        </div>
                        <div class="modal-footer justify-content-center">
                            <a href="${mediaPath}" target="_blank" class="btn btn-primary">
                                <i class="fas fa-external-link-alt me-1"></i> Yeni Sekmede Aç/İndir
                            </a>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="fas fa-times me-1"></i> Kapat
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();

            modal.addEventListener('hidden.bs.modal', () => {
                modal.remove();
            });
        }

        function getMediaMarkerIcon(mediaType) {
            const iconMap = {
                image: { icon: 'fa-camera', cls: 'image' },
                video: { icon: 'fa-video', cls: 'video' },
                audio: { icon: 'fa-music', cls: 'audio' },
                model_3d: { icon: 'fa-cube', cls: 'model_3d' }
            };
            const cfg = iconMap[mediaType] || { icon: 'fa-file', cls: 'image' };
            return L.divIcon({
                html: `<div class="media-marker ${cfg.cls}"><i class="fas ${cfg.icon}"></i></div>`,
                className: '',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }

        // Photo Location Management Functions
        let photoLocationMode = false;
        let selectedPhotoForLocation = null;
        let photoLocationMarkers = {};

        // Enable photo location selection mode
        function enablePhotoLocationSelection() {
            if (photoLocationMode) {
                disablePhotoLocationSelection();
                return;
            }

            photoLocationMode = true;
            document.getElementById('enablePhotoLocationBtn').innerHTML = '<i class="fas fa-times me-1"></i>Konum Seçimi İptal';
            document.getElementById('enablePhotoLocationBtn').classList.remove('btn-outline-primary');
            document.getElementById('enablePhotoLocationBtn').classList.add('btn-danger');
            
            // Add map click handler for location selection
            if (map) {
                map.getContainer().classList.add('select-location');
                map.once('click', handleMapClickForPhotoLocation);
            }
            
            showNotification('Haritaya tıklayarak fotoğraf konumu seçin', 'info');
        }

        // Disable photo location selection mode
        function disablePhotoLocationSelection() {
            photoLocationMode = false;
            document.getElementById('enablePhotoLocationBtn').innerHTML = '<i class="fas fa-crosshairs me-1"></i>Haritadan Konum Seç';
            document.getElementById('enablePhotoLocationBtn').classList.remove('btn-danger');
            document.getElementById('enablePhotoLocationBtn').classList.add('btn-outline-primary');
            
            if (map) {
                map.getContainer().classList.remove('select-location');
                map.off('click', handleMapClickForPhotoLocation);
            }
            
            selectedPhotoForLocation = null;
        }

        // Handle map click for photo location selection
        function handleMapClickForPhotoLocation(e) {
            if (!photoLocationMode || !selectedPhotoForLocation) return;
            
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            
            // Update photo location
            updatePhotoLocation(selectedPhotoForLocation, lat, lng);
            
            // Exit location selection mode
            disablePhotoLocationSelection();
        }

        // Add location to a photo
        async function addPhotoLocation(filename) {
            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            try {
                const response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}/location/auto`, {
                    method: 'POST',
                    credentials: 'include'
                });

                if (response.ok) {
                    const data = await response.json();
                    const media = data.media || {};
                    const lat = parseFloat(media.lat ?? media.latitude);
                    const lng = parseFloat(media.lng ?? media.longitude);
                    if (isFinite(lat) && isFinite(lng)) {
                        showNotification(`Konum otomatik eklendi: ${lat.toFixed(6)}, ${lng.toFixed(6)}`, 'success');
                        await loadRouteMediaForEdit(routeId);
                        return;
                    }
                }
            } catch (e) {
                console.warn('Otomatik konum eklenemedi:', e);
            }

            selectedPhotoForLocation = filename;
            enablePhotoLocationSelection();
            showNotification(`"${filename}" için konum seçimi aktif. Haritaya tıklayın.`, 'info');
        }

        // Edit existing photo location
        function editPhotoLocation(filename, currentLat, currentLng) {
            selectedPhotoForLocation = filename;
            enablePhotoLocationSelection();
            showNotification(`"${filename}" için yeni konum seçimi aktif. Haritaya tıklayın.`, 'info');
        }

        // Remove photo location
        async function removePhotoLocation(filename) {
            if (!confirm(`"${filename}" için konum bilgisini kaldırmak istediğinizden emin misiniz?`)) {
                return;
            }

            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            if (!routeId) {
                showNotification('Rota ID bulunamadı', 'error');
                return;
            }

            // Log the operation start
            logLocationOperation('remove_location_start', filename, routeId);

            try {
                // Remove location marker from map
                if (photoLocationMarkers[filename]) {
                    poiMarkersLayer.removeLayer(photoLocationMarkers[filename]);
                    delete photoLocationMarkers[filename];
                }

                // First try to use the dedicated location endpoint
                logLocationOperation('try_delete_endpoint', filename, routeId, { endpoint: `${apiBase}/admin/routes/${routeId}/media/${filename}/location` });
                
                let response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}/location`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken || ''
                    },
                    credentials: 'include'
                });

                logLocationOperation('delete_endpoint_response', filename, routeId, { status: response.status, statusText: response.statusText });

                if (response.ok) {
                    logLocationOperation('remove_location_success', filename, routeId, { method: 'DELETE endpoint' });
                    showNotification(`"${filename}" için konum kaldırıldı`, 'success');
                    
                    // Refresh media display
                    await loadRouteMediaForEdit(routeId);
                    
                    // Refresh elevation chart
                    if (window.routeElevationChart) {
                        refreshPhotoLocationMarkers();
                    }
                    return;
                }

                // Fallback: Update media metadata to remove location
                logLocationOperation('try_media_update', filename, routeId, { method: 'PATCH/PUT fallback' });
                
                const mediaResponse = await fetch(`${apiBase}/admin/routes/${routeId}/media`, { credentials: 'include' });
                if (mediaResponse.ok) {
                    const mediaJson = await mediaResponse.json();
                    const mediaItems = Array.isArray(mediaJson) ? mediaJson : (Array.isArray(mediaJson.media) ? mediaJson.media : []);
                    const mediaItem = mediaItems.find(m => (m.filename || m.name || m.path?.split('/').pop()) === filename);
                    
                    if (mediaItem) {
                        const updatedMedia = {
                            ...mediaItem,
                            lat: null,
                            lng: null,
                            latitude: null,
                            longitude: null
                        };
                        
                        // Remove filename to avoid duplicate parameter error
                        delete updatedMedia.filename;
                        
                        // Try PATCH method first, then PUT as fallback
                        logLocationOperation('try_patch_method', filename, routeId, { updatedMedia });
                        
                        response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': csrfToken || ''
                            },
                            credentials: 'include',
                            body: JSON.stringify(updatedMedia)
                        });

                        logLocationOperation('patch_response', filename, routeId, { status: response.status, statusText: response.statusText });

                        if (!response.ok) {
                            // Try PUT method as fallback
                            logLocationOperation('try_put_method', filename, routeId, { updatedMedia });
                            
                            response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': csrfToken || ''
                                },
                                credentials: 'include',
                                body: JSON.stringify(updatedMedia)
                            });
                            
                            logLocationOperation('put_response', filename, routeId, { status: response.status, statusText: response.statusText });
                        }

                        if (response.ok) {
                            logLocationOperation('remove_location_success', filename, routeId, { method: response.method || 'PATCH/PUT' });
                            showNotification(`"${filename}" için konum kaldırıldı`, 'success');
                            
                            // Refresh media display
                            await loadRouteMediaForEdit(routeId);
                            
                            // Refresh elevation chart
                            if (window.routeElevationChart) {
                                refreshPhotoLocationMarkers();
                            }
                        } else {
                            const errorData = await response.text();
                            logLocationOperation('remove_location_failed', filename, routeId, { 
                                status: response.status, 
                                statusText: response.statusText, 
                                errorData,
                                method: response.method || 'PATCH/PUT'
                            });
                            console.error('Location removal failed:', response.status, errorData);
                            throw new Error(`Konum kaldırılamadı (HTTP ${response.status}): ${errorData}`);
                        }
                    } else {
                        logLocationOperation('media_item_not_found', filename, routeId);
                        throw new Error('Medya dosyası bulunamadı');
                    }
                } else {
                    logLocationOperation('media_list_fetch_failed', filename, routeId, { status: mediaResponse.status });
                    throw new Error('Medya listesi alınamadı');
                }
            } catch (error) {
                logLocationOperation('remove_location_error', filename, routeId, { error: error.message, stack: error.stack });
                console.error('Error removing photo location:', error);
                showNotification('Konum kaldırılırken hata oluştu: ' + error.message, 'error');
            }
        }
        // Update photo location in the system
        async function updatePhotoLocation(filename, lat, lng) {
            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            if (!routeId) {
                showNotification('Rota ID bulunamadı', 'error');
                return;
            }

            try {
                // First try the dedicated location endpoint
                let response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}/location`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken || ''
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        latitude: lat,
                        longitude: lng,
                        filename: filename
                    })
                });

                // If the dedicated endpoint doesn't exist, try updating the media metadata
                if (!response.ok && response.status === 404) {
                    console.log('Location endpoint not found, trying media update...');
                    
                    // Get current media info
                    const mediaResponse = await fetch(`${apiBase}/admin/routes/${routeId}/media`, { credentials: 'include' });
                    if (mediaResponse.ok) {
                        const mediaJson = await mediaResponse.json();
                        const mediaItems = Array.isArray(mediaJson) ? mediaJson : (Array.isArray(mediaJson.media) ? mediaJson.media : []);
                        const mediaItem = mediaItems.find(m => (m.filename || m.name || m.path?.split('/').pop()) === filename);
                        
                        if (mediaItem) {
                            // Update the media item with location data
                            const updatedMedia = {
                                ...mediaItem,
                                lat: lat,
                                lng: lng,
                                latitude: lat,
                                longitude: lng
                            };
                            
                            // Remove filename to avoid duplicate parameter error
                            delete updatedMedia.filename;
                            
                            response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': csrfToken || ''
                                },
                                credentials: 'include',
                                body: JSON.stringify(updatedMedia)
                            });
                        }
                    }
                }

                if (response.ok) {
                    showNotification(`"${filename}" için konum güncellendi: ${lat.toFixed(6)}, ${lng.toFixed(6)}`, 'success');
                    
                    // Refresh media display
                    await loadRouteMediaForEdit(routeId);
                    
                    // Update map markers immediately with a default icon
                    updatePhotoLocationMarker(filename, lat, lng, 'image');

                    // Update elevation chart and refresh markers with actual types
                    refreshPhotoLocationMarkers();
                } else {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Konum güncellenemedi');
                }
            } catch (error) {
                console.error('Error updating photo location:', error);
                showNotification('Konum güncellenirken hata oluştu: ' + error.message, 'error');
            }
        }

        // Update photo location marker on map
        function updatePhotoLocationMarker(filename, lat, lng, mediaType = 'image') {
            // Remove existing marker if any
            if (photoLocationMarkers[filename]) {
                poiMarkersLayer.removeLayer(photoLocationMarkers[filename]);
                delete photoLocationMarkers[filename];
            }

            // Create new marker
            const typeLabels = { image: 'Fotoğraf', video: 'Video', audio: 'Ses', model_3d: '3D Model' };
            const label = typeLabels[mediaType] || 'Medya';
            const marker = L.marker([lat, lng], { icon: getMediaMarkerIcon(mediaType) })
                .bindPopup(`<div style="min-width:180px"><strong>${label}: ${filename}</strong><div style="margin-top:4px;color:#666">Konum: ${lat.toFixed(6)}, ${lng.toFixed(6)}</div></div>`);

            photoLocationMarkers[filename] = marker;
            poiMarkersLayer.addLayer(marker);
        }

        // Refresh all photo location markers
        async function refreshPhotoLocationMarkers() {
            if (!currentRoute) return;
            
            const routeId = getRouteId(currentRoute);
            if (!routeId) return;

            try {
                const response = await fetch(`${apiBase}/admin/routes/${routeId}/media`, { credentials: 'include' });
                if (response.ok) {
                    const mediaJson = await response.json();
                    const mediaItems = Array.isArray(mediaJson) ? mediaJson : (Array.isArray(mediaJson.media) ? mediaJson.media : []);

                    // Ensure media types
                    mediaItems.forEach(m => {
                        if (!m.media_type) {
                            const path = (m.filename || m.file_path || m.path || '').toLowerCase();
                            if (path.match(/\.(webp|jpg|jpeg|png|gif|bmp|tiff)$/)) m.media_type = 'image';
                            else if (path.match(/\.(mp4|avi|mov|wmv|flv|webm|mkv|m4v)$/)) m.media_type = 'video';
                            else if (path.match(/\.(mp3|wav|ogg|m4a|aac|flac)$/)) m.media_type = 'audio';
                            else if (path.match(/\.(glb|gltf|obj|fbx|dae|ply|stl)$/)) m.media_type = 'model_3d';
                            else m.media_type = 'unknown';
                        }
                    });

                    // Clear existing photo markers
                    Object.values(photoLocationMarkers).forEach(marker => {
                        poiMarkersLayer.removeLayer(marker);
                    });
                    photoLocationMarkers = {};

                    // Add markers for media with coordinates
                    const locatedMedia = mediaItems.filter(m => (m.lat || m.latitude) && (m.lng || m.longitude || m.lon));
                    locatedMedia.forEach(m => {
                        const lat = parseFloat(m.lat ?? m.latitude);
                        const lng = parseFloat(m.lng ?? m.longitude ?? m.lon);
                        const filename = m.filename || m.name || m.path?.split('/').pop() || 'Unknown';

                        if (isFinite(lat) && isFinite(lng)) {
                            updatePhotoLocationMarker(filename, lat, lng, m.media_type);
                        }
                    });

                    // Update elevation chart
                    if (window.routeElevationChart) {
                        window.routeElevationChart.setMediaMarkers(locatedMedia);
                    }
                }
            } catch (error) {
                console.error('Error refreshing photo location markers:', error);
            }
        }
        // Batch set photo locations from route coordinates
        async function batchSetPhotoLocations() {
            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            if (!routeId) return;

            try {
                // Get current media files
                const mediaResponse = await fetch(`${apiBase}/admin/routes/${routeId}/media`, { credentials: 'include' });
                if (!mediaResponse.ok) {
                    throw new Error('Medya dosyaları alınamadı');
                }

                const mediaJson = await mediaResponse.json();
                const mediaItems = Array.isArray(mediaJson) ? mediaJson : (Array.isArray(mediaJson.media) ? mediaJson.media : []);
                
                // Get route coordinates
                const routeResponse = await fetch(`${apiBase}/admin/routes/${routeId}`, { credentials: 'include' });
                if (!routeResponse.ok) {
                    throw new Error('Rota bilgileri alınamadı');
                }

                const routeData = await routeResponse.json();
                const route = routeData.route || routeData;
                
                let coordinates = [];
                if (route.coordinates && Array.isArray(route.coordinates)) {
                    coordinates = route.coordinates.map(coord => ({
                        lat: coord[1] || coord.lat || coord.latitude,
                        lng: coord[0] || coord.lng || coord.longitude
                    }));
                } else if (route.geometry && route.geometry.coordinates) {
                    coordinates = route.geometry.coordinates.map(coord => ({
                        lat: coord[1],
                        lng: coord[0]
                    }));
                }

                if (coordinates.length === 0) {
                    showNotification('Rota koordinatları bulunamadı', 'warning');
                    return;
                }

                // Distribute photos along route coordinates
                const photosWithoutLocation = mediaItems.filter(m => !(m.lat || m.latitude) && !(m.lng || m.longitude || m.lon));
                
                if (photosWithoutLocation.length === 0) {
                    showNotification('Konum belirlenmemiş fotoğraf bulunamadı', 'info');
                    return;
                }

                // Calculate distribution
                const step = Math.max(1, Math.floor(coordinates.length / photosWithoutLocation.length));
                let assignedCount = 0;

                for (let i = 0; i < photosWithoutLocation.length && i * step < coordinates.length; i++) {
                    const coord = coordinates[i * step];
                    const photo = photosWithoutLocation[i];
                    const filename = photo.filename || photo.name || photo.path?.split('/').pop() || 'Unknown';
                    
                    await updatePhotoLocation(filename, coord.lat, coord.lng);
                    assignedCount++;
                }

                showNotification(`${assignedCount} fotoğraf için konum atandı`, 'success');
                
                // Refresh display
                await loadRouteMediaForEdit(routeId);
                refreshPhotoLocationMarkers();

            } catch (error) {
                console.error('Error in batch location assignment:', error);
                showNotification('Toplu konum atama hatası: ' + error.message, 'error');
            }
        }

        // Export photo locations
        function exportPhotoLocations() {
            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            if (!routeId) {
                showNotification('Rota ID bulunamadı', 'error');
                return;
            }

            // Get all media with locations from the current display
            const mediaCards = document.querySelectorAll('.media-item-card.has-location');
            const locations = [];

            mediaCards.forEach(card => {
                const filename = card.dataset.mediaId;
                const lat = parseFloat(card.dataset.lat);
                const lng = parseFloat(card.dataset.lng);
                
                if (filename && !isNaN(lat) && !isNaN(lng)) {
                    locations.push({
                        filename: filename,
                        latitude: lat,
                        longitude: lng,
                        coordinates: `${lat.toFixed(6)}, ${lng.toFixed(6)}`
                    });
                }
            });

            if (locations.length === 0) {
                showNotification('Konum bulunamadı', 'warning');
                return;
            }

            // Create CSV content
            const csvContent = [
                'Dosya Adı,Enlem,Boylam,Koordinatlar',
                ...locations.map(loc => `${loc.filename},${loc.latitude},${loc.longitude},"${loc.coordinates}"`)
            ].join('\n');

            // Download CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `route_${routeId}_photo_locations.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showNotification(`${locations.length} konum CSV olarak dışa aktarıldı`, 'success');
        }

        // Import photo locations from CSV
        function importPhotoLocations() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const lines = text.split('\n');
                    const headers = lines[0].split(',');
                    
                    // Find column indices
                    const filenameIndex = headers.findIndex(h => h.includes('Dosya') || h.includes('File'));
                    const latIndex = headers.findIndex(h => h.includes('Enlem') || h.includes('Latitude') || h.includes('Lat'));
                    const lngIndex = headers.findIndex(h => h.includes('Boylam') || h.includes('Longitude') || h.includes('Lng'));

                    if (filenameIndex === -1 || latIndex === -1 || lngIndex === -1) {
                        throw new Error('CSV formatı tanınmadı. Gerekli sütunlar: Dosya Adı, Enlem, Boylam');
                    }

                    let importedCount = 0;
                    let errorCount = 0;

                    for (let i = 1; i < lines.length; i++) {
                        if (!lines[i].trim()) continue;
                        
                        const values = lines[i].split(',');
                        const filename = values[filenameIndex]?.trim().replace(/"/g, '');
                        const lat = parseFloat(values[latIndex]);
                        const lng = parseFloat(values[lngIndex]);

                        if (filename && !isNaN(lat) && !isNaN(lng)) {
                            try {
                                await updatePhotoLocation(filename, lat, lng);
                                importedCount++;
                            } catch (error) {
                                console.error(`Error importing location for ${filename}:`, error);
                                errorCount++;
                            }
                        }
                    }

                    if (importedCount > 0) {
                        showNotification(`${importedCount} konum başarıyla içe aktarıldı${errorCount > 0 ? `, ${errorCount} hata` : ''}`, 'success');
                    } else {
                        showNotification('Hiçbir konum içe aktarılamadı', 'warning');
                    }

                } catch (error) {
                    console.error('CSV import error:', error);
                    showNotification('CSV içe aktarma hatası: ' + error.message, 'error');
                }
            };

            input.click();
        }

        // Automatically extract EXIF location for all photos without location
        async function autoExtractAllPhotoLocations() {
            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            if (!routeId) {
                showNotification('Rota ID bulunamadı', 'error');
                return;
            }

            try {
                showNotification('Tüm fotoğraflar için EXIF konum bilgisi aranıyor...', 'info');

                // Get current media files
                const mediaResponse = await fetch(`${apiBase}/admin/routes/${routeId}/media`, { credentials: 'include' });
                if (!mediaResponse.ok) {
                    throw new Error('Medya dosyaları alınamadı');
                }

                const mediaJson = await mediaResponse.json();
                const mediaItems = Array.isArray(mediaJson) ? mediaJson : (Array.isArray(mediaJson.media) ? mediaJson.media : []);
                
                // Filter for images without location
                const imagesWithoutLocation = mediaItems.filter(m => 
                    m.media_type === 'image' && 
                    !(m.lat || m.latitude) && 
                    !(m.lng || m.longitude || m.lon)
                );

                if (imagesWithoutLocation.length === 0) {
                    showNotification('Konum belirlenmemiş fotoğraf bulunamadı', 'info');
                    return;
                }

                showNotification(`${imagesWithoutLocation.length} fotoğraf için EXIF konum bilgisi aranıyor...`, 'info');

                let extractedCount = 0;
                let failedCount = 0;

                for (const media of imagesWithoutLocation) {
                    const filename = media.filename || media.name || media.path?.split('/').pop() || 'Unknown';
                    
                    try {
                        // Try to extract location from EXIF
                        const locationResponse = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}/location/auto`, {
                            method: 'POST',
                            credentials: 'include'
                        });

                        if (locationResponse.ok) {
                            const locationData = await locationResponse.json();
                            if (locationData.success && locationData.media) {
                                const lat = parseFloat(locationData.media.lat ?? locationData.media.latitude);
                                const lng = parseFloat(locationData.media.lng ?? locationData.media.longitude);
                                
                                if (isFinite(lat) && isFinite(lng)) {
                                    extractedCount++;
                                    console.log(`✅ EXIF location extracted for ${filename}: ${lat}, ${lng}`);
                                } else {
                                    failedCount++;
                                    console.log(`❌ Invalid coordinates for ${filename}`);
                                }
                            } else {
                                failedCount++;
                                console.log(`❌ No EXIF location found for ${filename}`);
                            }
                        } else {
                            failedCount++;
                            console.log(`❌ EXIF extraction failed for ${filename}`);
                        }
                    } catch (error) {
                        failedCount++;
                        console.error(`Error extracting location for ${filename}:`, error);
                    }

                    // Small delay to avoid overwhelming the server
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Show results
                if (extractedCount > 0) {
                    showNotification(`🎯 ${extractedCount} fotoğraf için EXIF konum bilgisi başarıyla çıkarıldı!${failedCount > 0 ? ` (${failedCount} başarısız)` : ''}`, 'success');
                    
                    // Refresh media display
                    await loadRouteMediaForEdit(routeId);
                    
                    // Update map markers
                    refreshPhotoLocationMarkers();
                    
                    // Update elevation chart
                    if (window.routeElevationChart) {
                        refreshPhotoLocationMarkers();
                    }
                } else {
                    showNotification(`❌ Hiçbir fotoğraf için EXIF konum bilgisi çıkarılamadı (${failedCount} başarısız)`, 'warning');
                }

            } catch (error) {
                console.error('Error in auto EXIF extraction:', error);
                showNotification('Otomatik EXIF çıkarma hatası: ' + error.message, 'error');
            }
        }

        // Clear all photo locations
        async function clearAllPhotoLocations() {
            if (!currentRoute) {
                showNotification('Aktif rota bulunamadı', 'error');
                return;
            }

            const routeId = getRouteId(currentRoute);
            if (!routeId) {
                showNotification('Rota ID bulunamadı', 'error');
                return;
            }

            if (!confirm('Tüm fotoğraf konumlarını kaldırmak istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                return;
            }

            try {
                // Get current media files
                const mediaResponse = await fetch(`${apiBase}/admin/routes/${routeId}/media`, { credentials: 'include' });
                if (!mediaResponse.ok) {
                    throw new Error('Medya dosyaları alınamadı');
                }

                const mediaJson = await mediaResponse.json();
                const mediaItems = Array.isArray(mediaJson) ? mediaJson : (Array.isArray(mediaJson.media) ? mediaJson.media : []);
                
                // Clear all location markers from map
                Object.values(photoLocationMarkers).forEach(marker => {
                    poiMarkersLayer.removeLayer(marker);
                });
                photoLocationMarkers = {};

                // Remove locations from all media items
                let clearedCount = 0;
                for (const media of mediaItems) {
                    if ((media.lat || media.latitude) && (media.lng || media.longitude || media.lon)) {
                        const filename = media.filename || media.name || media.path?.split('/').pop() || 'Unknown';
                        
                        try {
                            const updatedMedia = {
                                ...media,
                                lat: null,
                                lng: null,
                                latitude: null,
                                longitude: null
                            };
                            
                            const response = await fetch(`${apiBase}/admin/routes/${routeId}/media/${filename}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': csrfToken || ''
                                },
                                credentials: 'include',
                                body: JSON.stringify(updatedMedia)
                            });

                            if (response.ok) {
                                clearedCount++;
                            }
                        } catch (error) {
                            console.error(`Error clearing location for ${filename}:`, error);
                        }
                    }
                }

                showNotification(`${clearedCount} fotoğraf konumu kaldırıldı`, 'success');
                
                // Refresh display
                await loadRouteMediaForEdit(routeId);
                
                // Refresh elevation chart
                if (window.routeElevationChart) {
                    refreshPhotoLocationMarkers();
                }

            } catch (error) {
                console.error('Error clearing photo locations:', error);
                showNotification('Fotoğraf konumları kaldırılırken hata oluştu: ' + error.message, 'error');
            }
        }

        // Enhanced elevation chart integration for photo locations
        function enhanceElevationChartWithPhotoLocations() {
            if (!window.routeElevationChart) return;
            
            // Add photo location markers to elevation chart
            const locatedMedia = Object.values(photoLocationMarkers).map(marker => {
                const latlng = marker.getLatLng();
                const filename = marker.options.filename || 'Unknown';
                return {
                    filename: filename,
                    latitude: latlng.lat,
                    longitude: latlng.lng,
                    lat: latlng.lat,
                    lng: latlng.lng
                };
            });
            
            if (locatedMedia.length > 0) {
                window.routeElevationChart.setMediaMarkers(locatedMedia);
                console.log('Photo locations added to elevation chart:', locatedMedia.length);
            }
        }

        // Update elevation chart when photo locations change
        function updateElevationChartPhotoLocations() {
            if (window.routeElevationChart && currentRoute) {
                enhanceElevationChartWithPhotoLocations();
            }
        }

        // Coordinate Management Functions
        let routeCoordinates = [];

        async function loadRouteCoordinates(routeId) {
            if (!routeId) return;

            try {
                const response = await fetch(`${apiBase}/admin/routes/${routeId}`, {
                    credentials: 'include'
                });
                if (!response.ok) return;

                const data = await response.json();
                const route = data.route || data;

                // Extract coordinates from route data
                routeCoordinates = [];
                
                if (route.coordinates && Array.isArray(route.coordinates)) {
                    route.coordinates.forEach((coord, index) => {
                        routeCoordinates.push({
                            id: index + 1,
                            lat: coord[1] || coord.lat || coord.latitude,
                            lng: coord[0] || coord.lng || coord.longitude,
                            name: `Nokta ${index + 1}`,
                            description: ''
                        });
                    });
                } else if (route.segments && Array.isArray(route.segments)) {
                    route.segments.forEach((segment, index) => {
                        if (segment.coordinates && Array.isArray(segment.coordinates)) {
                            segment.coordinates.forEach((coord, coordIndex) => {
                                routeCoordinates.push({
                                    id: routeCoordinates.length + 1,
                                    lat: coord[1] || coord.lat || coord.latitude,
                                    lng: coord[0] || coord.lng || coord.longitude,
                                    name: `Segment ${index + 1} - Nokta ${coordIndex + 1}`,
                                    description: ''
                                });
                            });
                        }
                    });
                }

                displayRouteCoordinates();

            } catch (error) {
                console.error('Error loading route coordinates:', error);
            }
        }

        function displayRouteCoordinates() {
            const container = document.getElementById('routeCoordinatesList');
            if (!container) return;

            if (routeCoordinates.length === 0) {
                container.innerHTML = '<div class="text-center text-muted py-3">Henüz koordinat eklenmemiş.</div>';
                return;
            }

            let coordinatesHtml = '';
            routeCoordinates.forEach((coord, index) => {
                coordinatesHtml += `
                    <div class="coordinate-item" data-index="${index}">
                        <div class="coordinate-number">${index + 1}</div>
                        <div class="coordinate-info">
                            <div class="coordinate-name">${coord.name}</div>
                            <div class="coordinate-coords">${coord.lat.toFixed(6)}, ${coord.lng.toFixed(6)}</div>
                            ${coord.description ? `<div class="coordinate-description">${coord.description}</div>` : ''}
                        </div>
                        <div class="coordinate-actions-item">
                            <button class="btn btn-sm btn-outline-primary" onclick="editCoordinate(${index})" title="Düzenle">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger" onclick="removeCoordinate(${index})" title="Sil">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = coordinatesHtml;
        }

        function addCoordinateToRoute() {
            const lat = parseFloat(document.getElementById('newCoordinateLat').value);
            const lng = parseFloat(document.getElementById('newCoordinateLng').value);
            const name = document.getElementById('newCoordinateName').value.trim();
            const description = document.getElementById('newCoordinateDescription').value.trim();

            if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                showNotification('Lütfen geçerli enlem ve boylam değerleri girin', 'error');
                return;
            }

            if (lat < -90 || lat > 90) {
                showNotification('Enlem değeri -90 ile 90 arasında olmalıdır', 'error');
                return;
            }

            if (lng < -180 || lng > 180) {
                showNotification('Boylam değeri -180 ile 180 arasında olmalıdır', 'error');
                return;
            }

            const newCoordinate = {
                id: routeCoordinates.length + 1,
                lat: lat,
                lng: lng,
                name: name || `Nokta ${routeCoordinates.length + 1}`,
                description: description
            };

            routeCoordinates.push(newCoordinate);
            displayRouteCoordinates();
            
            // Add marker to map
            addCoordinateMarker(newCoordinate);
            
            // Clear form
            clearCoordinateForm();
            
            showNotification('Koordinat başarıyla eklendi', 'success');
        }
        function getCurrentMapLocation() {
            if (map && map.getCenter) {
                const center = map.getCenter();
                document.getElementById('newCoordinateLat').value = center.lat.toFixed(6);
                document.getElementById('newCoordinateLng').value = center.lng.toFixed(6);
                showNotification('Harita merkezi koordinatları alındı', 'info');
            } else {
                showNotification('Harita henüz yüklenmemiş', 'error');
            }
        }

        function clearCoordinateForm() {
            document.getElementById('newCoordinateLat').value = '';
            document.getElementById('newCoordinateLng').value = '';
            document.getElementById('newCoordinateName').value = '';
            document.getElementById('newCoordinateDescription').value = '';
        }

        function editCoordinate(index) {
            const coord = routeCoordinates[index];
            if (!coord) return;

            // Populate form with existing values
            document.getElementById('newCoordinateLat').value = coord.lat;
            document.getElementById('newCoordinateLng').value = coord.lng;
            document.getElementById('newCoordinateName').value = coord.name;
            document.getElementById('newCoordinateDescription').value = coord.description;

            // Change button text and action
            const addBtn = document.querySelector('.coordinate-actions .btn-success');
            addBtn.innerHTML = '<i class="fas fa-save me-1"></i>Güncelle';
            addBtn.onclick = () => updateCoordinate(index);

            showNotification('Koordinat düzenleme moduna geçildi', 'info');
        }
        function updateCoordinate(index) {
            const lat = parseFloat(document.getElementById('newCoordinateLat').value);
            const lng = parseFloat(document.getElementById('newCoordinateLng').value);
            const name = document.getElementById('newCoordinateName').value.trim();
            const description = document.getElementById('newCoordinateDescription').value.trim();

            if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                showNotification('Lütfen geçerli enlem ve boylam değerleri girin', 'error');
                return;
            }

            routeCoordinates[index] = {
                ...routeCoordinates[index],
                lat: lat,
                lng: lng,
                name: name,
                description: description
            };

            displayRouteCoordinates();
            
            // Update marker on map
            updateCoordinateMarker(routeCoordinates[index]);
            
            // Reset form and button
            clearCoordinateForm();
            const addBtn = document.querySelector('.coordinate-actions .btn-success');
            addBtn.innerHTML = '<i class="fas fa-plus me-1"></i>Koordinat Ekle';
            addBtn.onclick = addCoordinateToRoute;
            
            showNotification('Koordinat başarıyla güncellendi', 'success');
        }

        function removeCoordinate(index) {
            if (!confirm(`Bu koordinatı silmek istediğinizden emin misiniz?`)) {
                return;
            }

            const coord = routeCoordinates[index];
            routeCoordinates.splice(index, 1);
            
            // Reorder IDs
            routeCoordinates.forEach((coord, idx) => {
                coord.id = idx + 1;
            });
            
            displayRouteCoordinates();
            
            // Remove marker from map
            removeCoordinateMarker(coord);
            
            showNotification('Koordinat başarıyla silindi', 'success');
        }

        function reorderCoordinates() {
            if (routeCoordinates.length < 2) {
                showNotification('Sıralama için en az 2 koordinat gerekli', 'info');
                return;
            }

            // Create a reordering interface with drag and drop
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.innerHTML = `
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Koordinat Sıralamasını Düzenle</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <p class="text-muted mb-3">Koordinatları sürükleyip bırakarak sıralayın:</p>
                            <div id="reorderCoordinatesList" class="coordinates-list">
                                ${routeCoordinates.map((coord, index) => `
                                    <div class="coordinate-item reorderable" data-index="${index}" draggable="true">
                                        <div class="coordinate-number">${index + 1}</div>
                                        <div class="coordinate-info">
                                            <div class="coordinate-name">${coord.name}</div>
                                            <div class="coordinate-coords">${coord.lat.toFixed(6)}, ${coord.lng.toFixed(6)}</div>
                                        </div>
                                        <div class="coordinate-actions-item">
                                            <i class="fas fa-grip-vertical text-muted"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">İptal</button>
                            <button type="button" class="btn btn-primary" onclick="saveCoordinateOrder()">Sıralamayı Kaydet</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();

            // Setup drag and drop functionality
            setupDragAndDrop();

            modal.addEventListener('hidden.bs.modal', () => {
                modal.remove();
            });
        }

        function setupDragAndDrop() {
            const reorderList = document.getElementById('reorderCoordinatesList');
            if (!reorderList) return;

            let draggedElement = null;

            reorderList.addEventListener('dragstart', function(e) {
                draggedElement = e.target.closest('.reorderable');
                if (draggedElement) {
                    draggedElement.style.opacity = '0.5';
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', draggedElement.outerHTML);
                }
            });

            reorderList.addEventListener('dragend', function(e) {
                if (draggedElement) {
                    draggedElement.style.opacity = '';
                    draggedElement = null;
                }
            });

            reorderList.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });

            reorderList.addEventListener('drop', function(e) {
                e.preventDefault();
                if (!draggedElement) return;

                const targetElement = e.target.closest('.reorderable');
                if (!targetElement || targetElement === draggedElement) return;

                const draggedIndex = parseInt(draggedElement.dataset.index);
                const targetIndex = parseInt(targetElement.dataset.index);

                // Reorder the coordinates array
                const [movedCoord] = routeCoordinates.splice(draggedIndex, 1);
                routeCoordinates.splice(targetIndex, 0, movedCoord);

                // Update the display
                updateReorderDisplay();
            });
        }

        function updateReorderDisplay() {
            const reorderList = document.getElementById('reorderCoordinatesList');
            if (!reorderList) return;

            reorderList.innerHTML = routeCoordinates.map((coord, index) => `
                <div class="coordinate-item reorderable" data-index="${index}" draggable="true">
                    <div class="coordinate-number">${index + 1}</div>
                    <div class="coordinate-info">
                        <div class="coordinate-name">${coord.name}</div>
                        <div class="coordinate-coords">${coord.lat.toFixed(6)}, ${coord.lng.toFixed(6)}</div>
                    </div>
                    <div class="coordinate-actions-item">
                        <i class="fas fa-grip-vertical text-muted"></i>
                    </div>
                </div>
            `).join('');

            // Re-setup drag and drop
            setupDragAndDrop();
        }
        function saveCoordinateOrder() {
            // This would typically save the new order to the backend
            // For now, we'll just show a success message
            showNotification('Koordinat sıralaması güncellendi', 'success');
            
            // Close modal
            const modal = document.querySelector('.modal.show');
            if (modal) {
                const bsModal = bootstrap.Modal.getInstance(modal);
                bsModal.hide();
            }
        }

        function clearAllCoordinates() {
            if (!confirm('Tüm koordinatları silmek istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                return;
            }

            routeCoordinates = [];
            displayRouteCoordinates();
            
            // Clear all coordinate markers from map
            clearAllCoordinateMarkers();
            
            showNotification('Tüm koordinatlar temizlendi', 'success');
        }

        // Map marker management for coordinates
        let coordinateMarkers = [];

        function addCoordinateMarker(coordinate) {
            if (!map) return;

            const marker = L.marker([coordinate.lat, coordinate.lng], {
                title: coordinate.name,
                draggable: true
            }).addTo(map);

            marker.bindPopup(`
                <div class="coordinate-popup">
                    <h6>${coordinate.name}</h6>
                    <p class="mb-1"><strong>Koordinat:</strong> ${coordinate.lat.toFixed(6)}, ${coordinate.lng.toFixed(6)}</p>
                    ${coordinate.description ? `<p class="mb-0"><em>${coordinate.description}</em></p>` : ''}
                </div>
            `);

            // Store marker reference
            coordinateMarkers.push({
                coordinate: coordinate,
                marker: marker
            });

            // Add drag event
            marker.on('dragend', function(e) {
                const newLat = e.target.getLatLng().lat;
                const newLng = e.target.getLatLng().lng;
                
                // Update coordinate data
                coordinate.lat = newLat;
                coordinate.lng = newLng;
                
                // Update display
                displayRouteCoordinates();
                
                showNotification('Koordinat haritada güncellendi', 'info');
            });
        }

        function updateCoordinateMarker(coordinate) {
            const markerData = coordinateMarkers.find(m => m.coordinate.id === coordinate.id);
            if (markerData) {
                markerData.marker.setLatLng([coordinate.lat, coordinate.lng]);
                markerData.marker.getPopup().setContent(`
                    <div class="coordinate-popup">
                        <h6>${coordinate.name}</h6>
                        <p class="mb-1"><strong>Koordinat:</strong> ${coordinate.lat.toFixed(6)}, ${coordinate.lng.toFixed(6)}</p>
                        ${coordinate.description ? `<p class="mb-0"><em>${coordinate.description}</em></p>` : ''}
                    </div>
                `);
            }
        }

        function removeCoordinateMarker(coordinate) {
            const markerData = coordinateMarkers.find(m => m.coordinate.id === coordinate.id);
            if (markerData) {
                map.removeLayer(markerData.marker);
                coordinateMarkers = coordinateMarkers.filter(m => m.coordinate.id !== coordinate.id);
            }
        }

        function clearAllCoordinateMarkers() {
            coordinateMarkers.forEach(markerData => {
                if (map) {
                    map.removeLayer(markerData.marker);
                }
            });
            coordinateMarkers = [];
        }

        // Add map click handler for adding coordinates
        function setupMapClickForCoordinates() {
            if (!map) return;

            // Remove existing click handler if any
            if (map._coordinateClickHandler) {
                map.off('click', map._coordinateClickHandler);
            }

            // Add new click handler
            map._coordinateClickHandler = function(e) {
                // Only add coordinates if we're in edit mode and the coordinate form is visible
                const coordinateForm = document.querySelector('.coordinate-input-form');
                if (coordinateForm && coordinateForm.style.display !== 'none') {
                    document.getElementById('newCoordinateLat').value = e.latlng.lat.toFixed(6);
                    document.getElementById('newCoordinateLng').value = e.latlng.lng.toFixed(6);
                    showNotification('Haritadan koordinat alındı. Nokta adı ve açıklama ekleyip "Koordinat Ekle" butonuna tıklayın.', 'info');
                }
            };

            map.on('click', map._coordinateClickHandler);
        }

        // Initialize coordinate management when route edit form is displayed
        function initializeCoordinateManagement() {
            // Setup map click handler
            setupMapClickForCoordinates();
            
            // Load existing coordinates if any
            if (currentRoute) {
                loadRouteCoordinates(getRouteId(currentRoute));
            }
        }

        function fitMapToRoutes() {
            if (map && Object.keys(routeLayers).length > 0) {
                // If there's a selected route, focus on it; otherwise show all routes
                if (currentRoute && routeLayers[getRouteId(currentRoute)]) {
                    const selectedLayer = routeLayers[getRouteId(currentRoute)];
                    const layers = [selectedLayer];

                    // Include POI markers if they exist
                    if (poiMarkersLayer && poiMarkersLayer.getLayers().length > 0) {
                        layers.push(poiMarkersLayer);
                    }

                    const group = new L.featureGroup(layers);
                    map.fitBounds(group.getBounds(), {
                        padding: [30, 30],
                        maxZoom: 14,
                        animate: true,
                        duration: 0.8
                    });
                    showNotification(`${currentRoute.name} rotasına odaklanıldı`, 'info');
                } else {
                    // Show all routes
                    const group = new L.featureGroup(Object.values(routeLayers));
                    map.fitBounds(group.getBounds(), {
                        padding: [20, 20],
                        animate: true,
                        duration: 0.8
                    });
                    showNotification('Tüm rotalara odaklanıldı', 'info');
                }
            } else {
                showNotification('Görüntülenecek rota bulunamadı', 'warning');
            }
        }

        function editCurrentRoute() {
            if (currentRoute) {
                displayRouteEditForm(currentRoute);
            }
        }
        // Display route editing form in workspace
        function displayRouteEditForm(route) {
            const workspaceTitle = document.getElementById('workspaceTitle');
            const workspaceActions = document.getElementById('workspaceActions');
            const workspaceContent = document.getElementById('workspaceContent');

            workspaceTitle.textContent = `${route.name} - Düzenleme`;
            workspaceActions.innerHTML = `
                <button class="btn-workspace" onclick="saveRouteChanges()">
                    <i class="fas fa-save me-1"></i>
                    Kaydet
                </button>
                <button class="btn-workspace" onclick="cancelRouteEdit()">
                    <i class="fas fa-times me-1"></i>
                    İptal
                </button>
            `;

            workspaceContent.innerHTML = `
                <div class="route-edit-form d-flex gap-3">
                    <form id="routeEditForm" class="flex-grow-1">
                        <div class="form-section">
                            <h5><i class="fas fa-info-circle me-2"></i>Temel Bilgiler</h5>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label for="editRouteName">Rota Adı *</label>
                                    <input type="text" id="editRouteName" class="form-control" 
                                           value="${escapeHtml(route.name)}" required>
                                </div>
                                <div class="form-group">
                                    <label for="editRouteType">Rota Türü *</label>
                                    <select id="editRouteType" class="form-control" required>
                                        <option value="walking" ${route.route_type === 'walking' ? 'selected' : ''}>🚶 Yürüyüş</option>
                                        <option value="hiking" ${route.route_type === 'hiking' ? 'selected' : ''}>🥾 Doğa Yürüyüşü</option>
                                        <option value="cycling" ${route.route_type === 'cycling' ? 'selected' : ''}>🚴 Bisiklet</option>
                                        <option value="driving" ${route.route_type === 'driving' ? 'selected' : ''}>🚗 Araba</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="editRouteDescription">Açıklama</label>
                                <textarea id="editRouteDescription" class="form-control" rows="3">${escapeHtml(route.description || '')}</textarea>
                            </div>
                        </div>

                        <div class="form-section">
                            <h5><i class="fas fa-chart-bar me-2"></i>Rota Özellikleri</h5>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label for="editDifficulty">Zorluk Seviyesi</label>
                                    <select id="editDifficulty" class="form-control">
                                        <option value="1" ${route.difficulty_level === 1 ? 'selected' : ''}>⭐ Çok Kolay</option>
                                        <option value="2" ${route.difficulty_level === 2 ? 'selected' : ''}>⭐⭐ Kolay</option>
                                        <option value="3" ${route.difficulty_level === 3 ? 'selected' : ''}>⭐⭐⭐ Orta</option>
                                        <option value="4" ${route.difficulty_level === 4 ? 'selected' : ''}>⭐⭐⭐⭐ Zor</option>
                                        <option value="5" ${route.difficulty_level === 5 ? 'selected' : ''}>⭐⭐⭐⭐⭐ Çok Zor</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="editDuration">Tahmini Süre (dakika)</label>
                                    <input type="number" id="editDuration" class="form-control" 
                                           value="${route.estimated_duration || ''}" min="1">
                                </div>
                                <div class="form-group">
                                    <label for="editDistance">Mesafe (km)</label>
                                    <input type="number" id="editDistance" class="form-control" 
                                           value="${route.total_distance || ''}" step="0.1" min="0">
                                </div>
                                <div class="form-group">
                                    <label for="editElevation">Yükselti Kazancı (m)</label>
                                    <input type="number" id="editElevation" class="form-control" 
                                           value="${route.elevation_gain || ''}" min="0">
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="editTags">Etiketler (virgülle ayırın)</label>
                                <input type="text" id="editTags" class="form-control" 
                                       value="${escapeHtml(route.tags || '')}" 
                                       placeholder="tarihi, doğa, macera">
                            </div>
                            
                            <div class="form-group">
                                <div class="form-check">
                                    <input type="checkbox" id="editIsCircular" class="form-check-input" 
                                           ${route.is_circular ? 'checked' : ''}>
                                    <label for="editIsCircular" class="form-check-label">
                                        Dairesel Rota (Başlangıç = Bitiş)
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h5><i class="fas fa-map-marker-alt me-2"></i>POI İlişkilendirme</h5>
                            <div class="poi-association-container">
                <div class="poi-search-section" onsubmit="return false;">
                                    <div class="search-container">
                                        <i class="fas fa-search search-icon"></i>
                                        <input type="text" class="search-input" id="poiSearchInput" 
                                               placeholder="POI ara..." oninput="searchPOIs()">
                                    </div>
                                    <div class="btn-group" role="group">
                                        <button type="button" class="btn btn-outline-primary" onclick="findNearbyPOIs()">
                                            <i class="fas fa-search-location me-1"></i>
                                            Yakın POI'leri Bul
                                        </button>
                                        <button type="button" class="btn btn-outline-success" onclick="autoAssociateNearbyPOIs()">
                                            <i class="fas fa-magic me-1"></i>
                                            Otomatik Ekle
                                        </button>
                                        <button type="button" class="btn btn-outline-info btn-sm" onclick="testNearbyFeature()">
                                            <i class="fas fa-bug me-1"></i>
                                            Test
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="poi-lists-container">
                                    <div class="available-pois">
                                        <h6>Mevcut POI'ler</h6>
                                        <div id="availablePOIsList" class="poi-list">
                                            <div class="loading-spinner">
                                                <div class="spinner"></div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="associated-pois">
                                        <h6>İlişkilendirilmiş POI'ler</h6>
                                        <div id="associatedPOIsList" class="poi-list">
                                            <!-- Associated POIs will be loaded here -->
                                        </div>
                                    </div>
                                </div>
                                <div class="mt-3">
                                    <button type="button" class="btn btn-primary" onclick="buildAndSaveRouteFromAssociatedPOIs()">
                                        <i class="fas fa-route me-1"></i>Rota Hesapla
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h5><i class="fas fa-map-marker-alt me-2"></i>Koordinat Yönetimi</h5>
                            <div class="coordinate-management-container">
                                <div class="coordinate-input-section">
                                    <h6><i class="fas fa-plus-circle me-2"></i>Yeni Koordinat Ekle</h6>
                                    
                                    <div class="coordinate-input-form">
                                        <div class="form-grid">
                                            <div class="form-group">
                                                <label for="newCoordinateLat">Enlem (Latitude) *</label>
                                                <input type="number" id="newCoordinateLat" class="form-control" 
                                                       step="any" placeholder="41.0082" required>
                                                <small class="form-help">Örnek: 41.0082 (İstanbul)</small>
                                            </div>
                                            <div class="form-group">
                                                <label for="newCoordinateLng">Boylam (Longitude) *</label>
                                                <input type="number" id="newCoordinateLng" class="form-control" 
                                                       step="any" placeholder="28.9784" required>
                                                <small class="form-help">Örnek: 28.9784 (İstanbul)</small>
                                            </div>
                                        </div>
                                        
                                        <div class="form-group">
                                            <label for="newCoordinateName">Nokta Adı</label>
                                            <input type="text" id="newCoordinateName" class="form-control" 
                                                   placeholder="Başlangıç noktası, mola yeri, vb.">
                                        </div>
                                        
                                        <div class="form-group">
                                            <label for="newCoordinateDescription">Açıklama</label>
                                            <textarea id="newCoordinateDescription" class="form-control" rows="2" 
                                                      placeholder="Bu nokta hakkında bilgi..."></textarea>
                                        </div>
                                        
                                        <div class="coordinate-actions">
                                            <button type="button" class="btn btn-success" onclick="addCoordinateToRoute()">
                                                <i class="fas fa-plus me-1"></i>Koordinat Ekle
                                            </button>
                                            <button type="button" class="btn btn-outline-info" onclick="getCurrentMapLocation()">
                                                <i class="fas fa-crosshairs me-1"></i>Haritadan Al
                                            </button>
                                            <button type="button" class="btn btn-outline-warning" onclick="clearCoordinateForm()">
                                                <i class="fas fa-eraser me-1"></i>Temizle
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="coordinate-list-section">
                                    <h6><i class="fas fa-list me-2"></i>Mevcut Koordinatlar</h6>
                                    <div id="routeCoordinatesList" class="coordinates-list">
                                        <div class="loading-spinner">
                                            <div class="spinner"></div>
                                            <p>Koordinatlar yükleniyor...</p>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="coordinate-actions-section">
                                    <button type="button" class="btn btn-primary" onclick="reorderCoordinates()">
                                        <i class="fas fa-sort me-1"></i>Sıralamayı Düzenle
                                    </button>
                                    <button type="button" class="btn btn-outline-danger" onclick="clearAllCoordinates()">
                                        <i class="fas fa-trash me-1"></i>Tümünü Temizle
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h5><i class="fas fa-download me-2"></i>Dışa Aktarma Seçenekleri</h5>
                            <div class="export-options">
                                <button type="button" class="btn btn-outline-info" onclick="exportRouteAsGPX(${getRouteId(route)})">
                                    <i class="fas fa-file-code me-1"></i>
                                    GPX Olarak İndir
                                </button>
                                <button type="button" class="btn btn-outline-info" onclick="exportRouteAsKML(${getRouteId(route)})">
                                    <i class="fas fa-globe me-1"></i>
                                    KML Olarak İndir
                                </button>
                                <button type="button" class="btn btn-outline-info" onclick="exportRouteAsJSON(${getRouteId(route)})">
                                    <i class="fas fa-code me-1"></i>
                                    JSON Olarak İndir
                                </button>
                                <button type="button" class="btn btn-outline-secondary" onclick="printRouteDetails(${getRouteId(route)})">
                                    <i class="fas fa-print me-1"></i>
                                    Yazdır
                                </button>
                            </div>
                        </div>
                    </form>
                    <div class="route-media-panel flex-grow-1">
                        <div class="media-upload-container">
                            <div class="media-upload-form">
                                <h5><i class="fas fa-photo-video me-2"></i>Medya Yönetimi</h5>
                                
                                <div class="form-group">
                                    <label class="form-label">
                                        <i class="fas fa-file-upload"></i>
                                        Medya Dosyası Seç
                                    </label>
                                    <input type="file" class="form-input" id="routeMediaFile"
                                        accept="image/*,video/*,audio/*,.glb,.gltf,.obj,.fbx,.dae,.ply,.stl">
                                    <small class="form-help">
                                        Desteklenen formatlar: Görsel (JPG, PNG, GIF), Video (MP4, AVI, MOV),
                                        Ses (MP3, WAV, OGG), 3D Model (GLB, GLTF, OBJ, FBX)<br>
                                        📸 Görseller isteğe bağlı olarak WebP formatına dönüştürülür
                                    </small>
                                </div>

                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Medya Türü</label>
                                        <select class="form-input" id="routeMediaType">
                                            <option value="auto">🔍 Otomatik Tespit</option>
                                            <option value="image">📸 Görsel</option>
                                            <option value="video">🎥 Video</option>
                                            <option value="audio">🎵 Ses</option>
                                            <option value="model_3d">🧊 3D Model</option>
                                        </select>
                                    </div>

                                    <div class="form-group">
                                        <label class="form-label">Açıklama</label>
                                        <input type="text" class="form-input" id="routeMediaCaption"
                                            placeholder="Medya açıklaması">
                                    </div>
                                </div>

                                <div class="form-group">
                                    <div class="form-check">
                                        <input type="checkbox" class="form-check-input" id="routeMediaPrimary">
                                        <label class="form-check-label" for="routeMediaPrimary">
                                            Ana medya olarak ayarla
                                        </label>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <div class="form-check">
                                        <input type="checkbox" class="form-check-input" id="routeMediaKeepOriginal">
                                        <label class="form-check-label" for="routeMediaKeepOriginal">
                                            Orijinal dosyayı (EXIF ile) yükle
                                        </label>
                                    </div>
                                    <small class="form-help">Seçilmezse görseller WebP formatına dönüştürülür.</small>
                                </div>

                                <button type="button" class="btn btn-primary" onclick="uploadRouteMedia()">
                                    <i class="fas fa-upload"></i>
                                    Medya Yükle
                                </button>
                            </div>

                            <!-- Photo Location Management -->
                            <div class="photo-location-management">
                                <h5><i class="fas fa-map-marker-alt me-2"></i>Fotoğraf Konum Yönetimi</h5>
                                <div class="photo-location-info">
                                    <div class="alert alert-info">
                                        <h6><i class="fas fa-info-circle me-2"></i>Fotoğraf Konum Yönetimi</h6>
                                        <p class="mb-2">
                                            Her fotoğraf için ayrı konum belirleyebilirsiniz. Konum belirlenen fotoğraflar harita ve yükseklik profili üzerinde gösterilecektir.
                                        </p>
                                        <div class="row">
                                            <div class="col-md-6">
                                                <h6 class="text-success"><i class="fas fa-magic me-1"></i>Otomatik EXIF Çıkarma</h6>
                                                <ul class="small text-muted">
                                                    <li>Fotoğraf yüklendiğinde EXIF GPS bilgisi otomatik olarak çıkarılır</li>
                                                    <li>EXIF konum bilgisi olan fotoğraflar haritada otomatik gösterilir</li>
                                                    <li>"EXIF'ten Otomatik Çıkar" butonu ile mevcut fotoğraflar işlenebilir</li>
                                                </ul>
                                            </div>
                                            <div class="col-md-6">
                                                <h6 class="text-primary"><i class="fas fa-map-marker-alt me-1"></i>Manuel Konum Ekleme</h6>
                                                <ul class="small text-muted">
                                                    <li>Haritaya tıklayarak manuel konum belirleyebilirsiniz</li>
                                                    <li>CSV dosyası ile toplu konum içe/dışa aktarımı yapabilirsiniz</li>
                                                    <li>Rota koordinatlarına göre otomatik konum atama mümkün</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="photo-location-controls">
                                    <button type="button" class="btn btn-outline-primary btn-sm" onclick="enablePhotoLocationSelection()" id="enablePhotoLocationBtn">
                                        <i class="fas fa-crosshairs me-1"></i>
                                        Haritadan Konum Seç
                                    </button>
                                    <button type="button" class="btn btn-outline-success btn-sm" onclick="batchSetPhotoLocations()" id="batchLocationBtn">
                                        <i class="fas fa-layer-group me-1"></i>
                                        Toplu Konum Ata
                                    </button>
                                    <button type="button" class="btn btn-outline-info btn-sm" onclick="autoExtractAllPhotoLocations()" id="autoExtractBtn" title="Tüm fotoğraflar için EXIF konum bilgisi otomatik çıkar">
                                        <i class="fas fa-magic me-1"></i>
                                        EXIF'ten Otomatik Çıkar
                                    </button>
                                    <button type="button" class="btn btn-outline-info btn-sm" onclick="exportPhotoLocations()" id="exportLocationsBtn">
                                        <i class="fas fa-download me-1"></i>
                                        Konumları Dışa Aktar
                                    </button>
                                    <button type="button" class="btn btn-outline-warning btn-sm" onclick="importPhotoLocations()" id="importLocationsBtn">
                                        <i class="fas fa-upload me-1"></i>
                                        Konumları İçe Aktar
                                    </button>
                                    <button type="button" class="btn btn-outline-danger btn-sm" onclick="clearAllPhotoLocations()" id="clearLocationsBtn">
                                        <i class="fas fa-trash me-1"></i>
                                        Tüm Konumları Temizle
                                    </button>
                                </div>
                            </div>

                            <!-- Current Media Files -->
                            <div class="current-media-container">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h5 class="mb-0"><i class="fas fa-folder-open"></i> Mevcut Medya Dosyaları</h5>
                                    <div class="btn-group" role="group">
                                        <button type="button" class="btn btn-outline-primary btn-sm" onclick="refreshRouteMedia()" title="Medya listesini yenile">
                                            <i class="fas fa-sync-alt"></i>
                                        </button>
                                        <button type="button" class="btn btn-outline-info btn-sm" onclick="testMediaLoading()" title="Medya yükleme testi">
                                            <i class="fas fa-bug"></i>
                                        </button>
                                    </div>
                                </div>
                                <div id="routeCurrentMedia" class="current-media-grid">
                                    <div class="loading-spinner">
                                        <div class="spinner"></div>
                                        <p>Medya dosyaları yükleniyor...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add CSS for edit form
            addRouteEditFormStyles();

            // Load POIs for association
            loadPOIsForAssociation(getRouteId(route));

                    // Load existing media for route
        if (typeof loadRouteMedia === 'function') {
            loadRouteMedia(getRouteId(route));
        }

        // Fotoğraf yükleme butonunun çalışması için medya dinleyicilerini kur
        if (window.routeAdminManager) {
            window.routeAdminManager.setupMediaHandlers();
        }

        // Load existing media for route - with delay to ensure DOM is ready
        setTimeout(async () => {
            try {
                await loadRouteMediaForEdit(getRouteId(route));
                console.log('Media loaded successfully for route:', getRouteId(route));
            } catch (error) {
                console.error('Failed to load media for route:', getRouteId(route), error);
            }
        }, 500);

        // Additional media initialization to ensure it works
        setTimeout(async () => {
            try {
                const container = document.getElementById('routeCurrentMedia');
                if (container && container.innerHTML.includes('loading-spinner')) {
                    console.log('Media container still loading, retrying...');
                    await loadRouteMediaForEdit(getRouteId(route));
                }
            } catch (error) {
                console.warn('Additional media initialization failed:', error);
            }
        }, 1500);
        
                    // Load existing coordinates for route
            loadRouteCoordinates(getRouteId(route));
            
            // Initialize coordinate management
            initializeCoordinateManagement();
            
            // Refresh photo location markers
            setTimeout(() => {
                refreshPhotoLocationMarkers();
            }, 500);

            // Final media initialization check
            setTimeout(async () => {
                try {
                    const container = document.getElementById('routeCurrentMedia');
                    if (container) {
                        console.log('Final media container check - container exists');
                        if (container.innerHTML.includes('loading-spinner') || container.innerHTML.includes('Medya dosyaları yükleniyor')) {
                            console.log('Media container still in loading state, final retry...');
                            await loadRouteMediaForEdit(getRouteId(route));
                        }
                    } else {
                        console.warn('Final check - media container still not found');
                    }
                } catch (error) {
                    console.warn('Final media initialization failed:', error);
                }
            }, 2000);
        }
        // Add styles for route edit form
        function addRouteEditFormStyles() {
            if (document.getElementById('routeEditFormStyles')) return;

            const style = document.createElement('style');
            style.id = 'routeEditFormStyles';
            style.textContent = `
                .route-edit-form {
                    padding: 0;
                }

                .form-section {
                    margin-bottom: 2rem;
                    padding-bottom: 1.5rem;
                    border-bottom: 2px solid var(--route-border);
                }

                .form-section:last-child {
                    border-bottom: none;
                }

                .form-section h5 {
                    color: var(--route-dark);
                    margin-bottom: 1rem;
                    font-weight: 600;
                }

                .form-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 1rem;
                    margin-bottom: 1rem;
                }

                .form-group {
                    display: flex;
                    flex-direction: column;
                    gap: 0.5rem;
                }

                .form-group label {
                    font-weight: 600;
                    color: var(--route-dark);
                    font-size: 0.9rem;
                }

                .form-control {
                    padding: 0.75rem;
                    border: 2px solid var(--route-border);
                    border-radius: var(--route-radius);
                    font-size: 0.9rem;
                    transition: var(--route-transition);
                }

                .form-control:focus {
                    outline: none;
                    border-color: var(--route-primary);
                    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
                }

                .form-check {
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                    margin-top: 0.5rem;
                }

                .form-check-input {
                    width: 18px;
                    height: 18px;
                }

                /* Media Management Styles */
                .media-upload-container {
                    background: white;
                    border-radius: var(--route-radius);
                    padding: 1.5rem;
                    box-shadow: var(--route-shadow);
                }

                .media-upload-form h5 {
                    color: var(--route-dark);
                    margin-bottom: 1.5rem;
                    font-weight: 600;
                    border-bottom: 2px solid var(--route-border);
                    padding-bottom: 0.5rem;
                }

                .form-input {
                    padding: 0.75rem;
                    border: 2px solid var(--route-border);
                    border-radius: var(--route-radius);
                    font-size: 0.9rem;
                    transition: var(--route-transition);
                    width: 100%;
                }

                .form-input:focus {
                    outline: none;
                    border-color: var(--route-primary);
                    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
                }

                .form-label {
                    font-weight: 600;
                    color: var(--route-dark);
                    font-size: 0.9rem;
                    margin-bottom: 0.5rem;
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                }

                .form-help {
                    color: var(--route-secondary);
                    font-size: 0.8rem;
                    margin-top: 0.25rem;
                }

                .current-media-container {
                    margin-top: 2rem;
                    padding-top: 1.5rem;
                    border-top: 2px solid var(--route-border);
                }

                .current-media-container h5 {
                    color: var(--route-dark);
                    margin-bottom: 1rem;
                    font-weight: 600;
                }

                .current-media-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                    gap: 1rem;
                    margin-top: 1rem;
                }

                .media-item-card {
                    position: relative;
                    background: white;
                    border: 2px solid var(--route-border);
                    border-radius: var(--route-radius);
                    padding: 0.75rem;
                    text-align: center;
                    transition: var(--route-transition);
                    cursor: pointer;
                }

                .media-item-card:hover {
                    border-color: var(--route-primary);
                    box-shadow: var(--route-shadow-hover);
                    transform: translateY(-2px);
                }

                .media-preview {
                    width: 100%;
                    height: 80px;
                    object-fit: cover;
                    border-radius: calc(var(--route-radius) - 4px);
                    margin-bottom: 0.5rem;
                    /* Ensure WebP images are properly displayed */
                    image-rendering: -webkit-optimize-contrast;
                    image-rendering: crisp-edges;
                }

                .media-placeholder {
                    width: 100%;
                    height: 80px;
                    background: var(--route-light);
                    border: 2px dashed var(--route-border);
                    border-radius: calc(var(--route-radius) - 4px);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    margin-bottom: 0.5rem;
                    font-size: 1.5rem;
                }

                .media-format {
                    font-size: 0.7rem;
                    color: var(--route-secondary);
                    margin-top: 0.25rem;
                }

                .media-delete-btn {
                    position: absolute;
                    top: -8px;
                    right: -8px;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    background: var(--route-danger);
                    color: white;
                    border: none;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.8rem;
                    transition: var(--route-transition);
                }

                .media-delete-btn:hover {
                    background: #b91c1c;
                    transform: scale(1.1);
                }

                .media-type-badge {
                    position: absolute;
                    top: 0.5rem;
                    left: 0.5rem;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 0.25rem 0.5rem;
                    border-radius: 12px;
                    font-size: 0.8rem;
                }

                .media-item-info {
                    margin-top: 0.5rem;
                }

                .media-item-name {
                    font-size: 0.8rem;
                    font-weight: 600;
                    color: var(--route-dark);
                    margin-bottom: 0.25rem;
                    word-break: break-word;
                }

                .media-type-section {
                    margin-bottom: 2rem;
                }

                .media-type-title {
                    font-size: 1rem;
                    font-weight: 600;
                    color: var(--route-dark);
                    margin-bottom: 1rem;
                    padding-bottom: 0.5rem;
                    border-bottom: 2px solid var(--route-border);
                }

                .current-media-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                    gap: 1rem;
                    margin-top: 1rem;
                }

                .media-item-size {
                    font-size: 0.7rem;
                    color: var(--route-secondary);
                }
                
                .media-compression {
                    font-size: 0.7rem;
                    color: #059669;
                    font-weight: 500;
                }

                .loading-spinner {
                    text-align: center;
                    padding: 2rem;
                    color: var(--route-secondary);
                }

                .spinner {
                    width: 40px;
                    height: 40px;
                    border: 4px solid var(--route-border);
                    border-top: 4px solid var(--route-primary);
                    border-radius: 50%;
                    animation: spin 1s linear infinite;
                    margin: 0 auto 1rem;
                }

                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }

                /* Coordinate Management Styles */
                .coordinate-management-container {
                    background: white;
                    border-radius: var(--route-radius);
                    padding: 1.5rem;
                    box-shadow: var(--route-shadow);
                }

                .coordinate-input-section h6,
                .coordinate-list-section h6 {
                    color: var(--route-dark);
                    margin-bottom: 1rem;
                    font-weight: 600;
                    border-bottom: 1px solid var(--route-border);
                    padding-bottom: 0.5rem;
                }

                .coordinate-input-form {
                    background: var(--route-light);
                    border-radius: var(--route-radius);
                    padding: 1rem;
                    margin-bottom: 1.5rem;
                }

                .coordinate-actions {
                    display: flex;
                    gap: 0.75rem;
                    margin-top: 1rem;
                    flex-wrap: wrap;
                }

                .coordinate-actions .btn {
                    flex: 1;
                    min-width: 120px;
                }

                .coordinates-list {
                    background: var(--route-light);
                    border-radius: var(--route-radius);
                    padding: 1rem;
                    margin-bottom: 1rem;
                    max-height: 300px;
                    overflow-y: auto;
                }

                .coordinate-item {
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    padding: 0.75rem;
                    background: white;
                    border: 1px solid var(--route-border);
                    border-radius: calc(var(--route-radius) - 4px);
                    margin-bottom: 0.5rem;
                    transition: var(--route-transition);
                }

                .coordinate-item:hover {
                    border-color: var(--route-primary);
                    box-shadow: var(--route-shadow);
                }

                .coordinate-item:last-child {
                    margin-bottom: 0;
                }

                .coordinate-number {
                    background: var(--route-primary);
                    color: white;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.8rem;
                    font-weight: 600;
                    flex-shrink: 0;
                }

                .coordinate-info {
                    flex: 1;
                }

                .coordinate-name {
                    font-weight: 600;
                    color: var(--route-dark);
                    margin-bottom: 0.25rem;
                }

                .coordinate-coords {
                    font-family: monospace;
                    font-size: 0.8rem;
                    color: var(--route-secondary);
                    margin-bottom: 0.25rem;
                }

                .coordinate-description {
                    font-size: 0.8rem;
                    color: var(--route-secondary);
                    font-style: italic;
                }

                .coordinate-actions-item {
                    display: flex;
                    gap: 0.5rem;
                    flex-shrink: 0;
                }

                .coordinate-actions-section {
                    display: flex;
                    gap: 1rem;
                    justify-content: center;
                    padding-top: 1rem;
                    border-top: 1px solid var(--route-border);
                }

                .coordinate-actions-section .btn {
                    min-width: 150px;
                }

                .coordinate-item.reorderable {
                    cursor: grab;
                    user-select: none;
                }

                .coordinate-item.reorderable:active {
                    cursor: grabbing;
                }

                .coordinate-item.reorderable:hover {
                    background: var(--route-light);
                    border-color: var(--route-primary);
                }

                .coordinate-item.reorderable.dragging {
                    opacity: 0.5;
                    transform: rotate(2deg);
                }

                .media-type-section {
                    margin-bottom: 1.5rem;
                }

                .media-type-title {
                    color: var(--route-dark);
                    margin-bottom: 1rem;
                    font-weight: 600;
                    font-size: 0.9rem;
                    border-bottom: 1px solid var(--route-border);
                    padding-bottom: 0.5rem;
                }

                .poi-association-container {
                    background: var(--route-light);
                    border-radius: var(--route-radius);
                    padding: 1rem;
                    border: 2px solid var(--route-border);
                }

                .poi-search-section {
                    display: flex;
                    gap: 1rem;
                    align-items: center;
                    margin-bottom: 1rem;
                }

                .poi-search-section .search-container {
                    flex: 1;
                }

                .poi-lists-container {
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 1rem;
                }

                .available-pois, .associated-pois {
                    background: white;
                    border-radius: var(--route-radius);
                    padding: 1rem;
                    border: 2px solid var(--route-border);
                }

                .available-pois h6, .associated-pois h6 {
                    margin-bottom: 0.75rem;
                    color: var(--route-dark);
                    font-weight: 600;
                }

                .poi-list {
                    max-height: 200px;
                    overflow-y: auto;
                }

                .poi-item-small {
                    background: var(--route-light);
                    border: 1px solid var(--route-border);
                    border-radius: var(--route-radius);
                    padding: 0.75rem;
                    margin-bottom: 0.5rem;
                    cursor: pointer;
                    transition: var(--route-transition);
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .poi-item-small:hover {
                    border-color: var(--route-primary);
                    background: white;
                }

                .poi-item-info {
                    flex: 1;
                }
                .poi-item-name {
                    font-weight: 600;
                    color: var(--route-dark);
                    font-size: 0.9rem;
                }

                .poi-item-category {
                    font-size: 0.8rem;
                    color: var(--route-secondary);
                }

                .poi-item-actions {
                    display: flex;
                    gap: 0.25rem;
                }

                .btn-poi-action {
                    padding: 0.25rem 0.5rem;
                    border: none;
                    border-radius: 15px;
                    font-size: 0.75rem;
                    cursor: pointer;
                    transition: var(--route-transition);
                }

                .btn-add-poi {
                    background: var(--route-success);
                    color: white;
                }

                .btn-remove-poi {
                    background: var(--route-danger);
                    color: white;
                }

                .poi-order-badge {
                    display: inline-block;
                    background: var(--route-primary);
                    color: white;
                    border-radius: 50%;
                    width: 20px;
                    height: 20px;
                    text-align: center;
                    line-height: 20px;
                    font-size: 0.7rem;
                    font-weight: bold;
                    margin-right: 0.5rem;
                }

                .export-options {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 0.75rem;
                }

                .export-options .btn {
                    padding: 0.5rem 1rem;
                    border-radius: 20px;
                    font-size: 0.85rem;
                    font-weight: 500;
                }

                .current-media-container .btn-group {
                    gap: 0.25rem;
                }

                .current-media-container .btn-group .btn {
                    min-width: auto;
                    padding: 0.25rem 0.5rem;
                    font-size: 0.8rem;
                }

                @media (max-width: 768px) {
                    .form-grid {
                        grid-template-columns: 1fr;
                    }

                    .poi-lists-container {
                        grid-template-columns: 1fr;
                    }

                    .poi-search-section {
                        flex-direction: column;
                        align-items: stretch;
                    }

                    .export-options {
                        flex-direction: column;
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Load POIs for association
        async function loadPOIsForAssociation(routeId) {
            console.log('Loading POIs for association with route:', routeId);

            try {
                // Show loading state
                const availableContainer = document.getElementById('availablePOIsList');
                const associatedContainer = document.getElementById('associatedPOIsList');

                if (availableContainer) {
                    availableContainer.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
                }
                if (associatedContainer) {
                    associatedContainer.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
                }

                // Load all POIs
                const poisResponse = await fetch(`${apiBase}/pois`, { credentials: 'include' });
                let allPOIs = [];

                if (poisResponse.ok) {
                    const raw = await poisResponse.json();
                    console.log('All POIs response:', raw);

                    if (Array.isArray(raw)) {
                        allPOIs = raw;
                    } else if (Array.isArray(raw.pois)) {
                        allPOIs = raw.pois;
                    } else if (Array.isArray(raw.results)) {
                        allPOIs = raw.results;
                    } else {
                        // Handle categorized POIs
                        Object.values(raw || {}).forEach(v => {
                            if (Array.isArray(v)) allPOIs = allPOIs.concat(v);
                        });
                    }
                    console.log('Processed all POIs:', allPOIs.length);
                    allPoisForAssociation = allPOIs.slice();
                } else {
                    console.error('Failed to load POIs:', poisResponse.status);
                    throw new Error('POI\'ler yüklenemedi');
                }

                // Load route detail with associated POIs
                const routeDetailResp = await fetch(`${apiBase}/admin/routes/${routeId}`, { credentials: 'include' });
                let associatedPOIs = [];

                if (routeDetailResp.ok) {
                    const routeDetail = await routeDetailResp.json();
                    console.log('Route detail response:', routeDetail);

                    if (Array.isArray(routeDetail?.pois)) {
                        associatedPOIs = routeDetail.pois;
                    }
                    console.log('Associated POIs from route:', associatedPOIs.length);
                } else {
                    console.error('Failed to load route detail:', routeDetailResp.status);
                }

                // Process associated POIs and update global state
                const assocList = associatedPOIs.slice();
                assocList.sort((a, b) => (a.order_in_route || 0) - (b.order_in_route || 0));

                associatedPoiOrderedIds = assocList
                    .map(p => {
                        // Handle different POI ID formats
                        const id = getPoiId(p) || (p.poi ? getPoiId(p.poi) : null);
                        return id ? parseInt(id) : null;
                    })
                    .filter(id => id != null && Number.isFinite(id));

                associatedPoiIdSet = new Set(associatedPoiOrderedIds);

                console.log('Associated POI IDs (ordered):', associatedPoiOrderedIds);
                console.log('Associated POI ID set:', Array.from(associatedPoiIdSet));

                // Separate available and associated POIs
                const associatedPOIIds = new Set(associatedPoiOrderedIds);
                const availablePOIs = allPOIs.filter(poi => {
                    const poiId = parseInt(getPoiId(poi));
                    return Number.isFinite(poiId) && !associatedPOIIds.has(poiId);
                });

                // Get associated POI objects in correct order
                const orderedAssociatedPOIs = associatedPoiOrderedIds
                    .map(id => allPOIs.find(poi => parseInt(getPoiId(poi)) === id))
                    .filter(poi => poi != null);

                console.log('Available POIs:', availablePOIs.length);
                console.log('Ordered associated POIs:', orderedAssociatedPOIs.length);

                // Display POI lists
                displayAvailablePOIs(availablePOIs);
                displayAssociatedPOIs(orderedAssociatedPOIs);

            } catch (error) {
                console.error('Error loading POIs for association:', error);
                showNotification("POI'ler yüklenirken hata oluştu: " + error.message, 'error');

                // Show error state
                const availableContainer = document.getElementById('availablePOIsList');
                const associatedContainer = document.getElementById('associatedPOIsList');

                if (availableContainer) {
                    availableContainer.innerHTML = '<p class="text-danger">POI\'ler yüklenemedi</p>';
                }
                if (associatedContainer) {
                    associatedContainer.innerHTML = '<p class="text-danger">İlişkili POI\'ler yüklenemedi</p>';
                }
            }
        }

        // Display available POIs
        function displayAvailablePOIs(pois) {
            const container = document.getElementById('availablePOIsList');

            console.log('Displaying', pois.length, 'available POIs');

            if (!container) {
                console.warn('Available POIs container not found');
                return;
            }

            if (pois.length === 0) {
                console.log('No available POIs to display, showing empty message');
                container.innerHTML = '<p class="text-muted">İlişkilendirilecek POI bulunamadı</p>';
                return;
            }

            console.log('Displaying available POIs:', pois.length);

            container.innerHTML = pois.map(poi => {
                const poiId = getPoiId(poi);
                if (!poiId) {
                    console.warn('POI without ID:', poi);
                    return '';
                }

                // Get category info for icon
                const category = POI_CATEGORIES[poi.category] || {
                    icon: 'map-marker-alt',
                    color: '#2563eb',
                    name: poi.category || 'Kategori yok'
                };

                return `
                    <div class="poi-item-small" data-poi-id="${poiId}">
                        <div class="poi-item-info">
                            <div class="poi-item-name">
                                <i class="fas fa-${category.icon}" style="color: ${category.color}; margin-right: 0.5rem;"></i>
                                ${escapeHtml(poi.name || 'İsimsiz POI')}
                            </div>
                            <div class="poi-item-category">${category.name}</div>
                        </div>
                        <div class="poi-item-actions">
                            <button type="button" class="btn-poi-action btn-add-poi" onclick="associatePOI(${poiId})" title="POI'yi rotaya ekle">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).filter(html => html).join('');

            console.log('Available POIs displayed successfully');
        }
        // Display associated POIs
        function displayAssociatedPOIs(pois) {
            const container = document.getElementById('associatedPOIsList');

            console.log('Displaying', pois.length, 'associated POIs');

            if (!container) {
                console.warn('Associated POIs container not found');
                return;
            }

            if (pois.length === 0) {
                console.log('No POIs to display, showing empty message');
                container.innerHTML = '<p class="text-muted">İlişkilendirilmiş POI bulunmuyor</p>';
                return;
            }

            console.log('Displaying associated POIs:', pois.length);

            container.innerHTML = pois.map((poi, idx) => {
                const poiId = getPoiId(poi);
                if (!poiId) {
                    console.warn('Associated POI without ID:', poi);
                    return '';
                }

                // Get category info for icon
                const category = POI_CATEGORIES[poi.category] || {
                    icon: 'map-marker-alt',
                    color: '#2563eb',
                    name: poi.category || 'Kategori yok'
                };

                return `
                    <div class="poi-item-small" data-poi-id="${poiId}">
                        <div class="poi-item-info">
                            <div class="poi-item-name">
                                <span class="poi-order-badge">${idx + 1}</span>
                                <i class="fas fa-${category.icon}" style="color: ${category.color}; margin-right: 0.5rem;"></i>
                                ${escapeHtml(poi.name || 'İsimsiz POI')}
                            </div>
                            <div class="poi-item-category">${category.name}</div>
                        </div>
                        <div class="poi-item-actions">
                            <button type="button" class="btn-poi-action btn-remove-poi" onclick="disassociatePOI(${poiId})" title="POI'yi rotadan çıkar">
                                <i class="fas fa-times"></i>
                            </button>
                            ${idx > 0 ? `<button type="button" class="btn-poi-action" title="Yukarı taşı" onclick="reorderAssociatedPOI(${poiId}, -1)"><i class="fas fa-arrow-up"></i></button>` : ''}
                            ${idx < pois.length - 1 ? `<button type="button" class="btn-poi-action" title="Aşağı taşı" onclick="reorderAssociatedPOI(${poiId}, 1)"><i class="fas fa-arrow-down"></i></button>` : ''}
                        </div>
                    </div>
                `;
            }).filter(html => html).join('');

            console.log('Associated POIs displayed successfully');
        }
        // Search POIs
        function searchPOIs() {
            const searchTerm = document.getElementById('poiSearchInput').value.toLowerCase();
            const availableItems = document.querySelectorAll('#availablePOIsList .poi-item-small');
            const associatedItems = document.querySelectorAll('#associatedPOIsList .poi-item-small');

            [...availableItems, ...associatedItems].forEach(item => {
                const name = item.querySelector('.poi-item-name').textContent.toLowerCase();
                const category = item.querySelector('.poi-item-category').textContent.toLowerCase();

                if (name.includes(searchTerm) || category.includes(searchTerm)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // Associate POI with route
        async function associatePOI(poiId) {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'warning');
                return;
            }

            try {
                console.log('Associating POI:', poiId, 'with route:', getRouteId(currentRoute));

                const headers = { 'Content-Type': 'application/json' };
                if (csrfToken) headers['X-CSRFToken'] = csrfToken;

                const idInt = parseInt(poiId);
                if (!Number.isFinite(idInt)) {
                    console.error('Invalid POI ID:', poiId);
                    showNotification('Geçersiz POI ID', 'error');
                    return;
                }

                // Add to current set and preserve order
                if (!associatedPoiIdSet.has(idInt)) {
                    associatedPoiOrderedIds.push(idInt);
                    associatedPoiIdSet.add(idInt);
                    console.log('Added POI to local set. New order:', associatedPoiOrderedIds);
                } else {
                    console.log('POI already in set, skipping local add');
                }

                // Send updated POI list to backend
                const payloadPois = associatedPoiOrderedIds.map((id, idx) => ({
                    poi_id: id,
                    order_in_route: idx + 1
                }));

                console.log('Sending POI payload:', payloadPois);

                const url = `${apiBase}/admin/routes/${getRouteId(currentRoute)}/pois`;
                console.log('API URL:', url);

                const requestBody = {
                    csrf_token: csrfToken || '',
                    pois: payloadPois
                };
                console.log('Request body:', requestBody);

                const response = await fetch(url, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));

                if (response.ok) {
                    const result = await response.json();
                    console.log('POI association response:', result);
                    showNotification('POI başarıyla ilişkilendirildi', 'success');

                    // Reload POI lists to reflect changes
                    console.log('Reloading POI lists...');
                    await loadPOIsForAssociation(getRouteId(currentRoute));

                    // Update route visualization on map
                    console.log('Updating route visualization...');
                    await showSelectedRouteOnMap(currentRoute);
                } else {
                    const responseText = await response.text();
                    console.error('POI association failed:', response.status, responseText);

                    let errorData = {};
                    try {
                        errorData = JSON.parse(responseText);
                    } catch (e) {
                        errorData = { error: responseText };
                    }

                    throw new Error(errorData.error || 'POI ilişkilendirilemedi');
                }
            } catch (error) {
                console.error('POI association error:', error);
                showNotification('POI ilişkilendirilirken hata oluştu: ' + error.message, 'error');

                // Revert local changes on error
                const idInt = parseInt(poiId);
                if (associatedPoiIdSet.has(idInt)) {
                    associatedPoiOrderedIds = associatedPoiOrderedIds.filter(id => id !== idInt);
                    associatedPoiIdSet.delete(idInt);
                    console.log('Reverted local changes. New order:', associatedPoiOrderedIds);
                }
            }
        }
        // Disassociate POI from route
        async function disassociatePOI(poiId) {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'warning');
                return;
            }

            try {
                console.log('Disassociating POI:', poiId, 'from route:', getRouteId(currentRoute));

                const headers = { 'Content-Type': 'application/json' };
                if (csrfToken) headers['X-CSRFToken'] = csrfToken;

                const idInt = parseInt(poiId);
                if (!Number.isFinite(idInt)) {
                    showNotification('Geçersiz POI ID', 'error');
                    return;
                }

                // Store original state for rollback
                const originalOrderedIds = [...associatedPoiOrderedIds];
                const originalIdSet = new Set(associatedPoiIdSet);

                // Remove from both ordered list and set
                associatedPoiOrderedIds = associatedPoiOrderedIds.filter(id => id !== idInt);
                associatedPoiIdSet.delete(idInt);

                console.log('Removed POI from local set. New order:', associatedPoiOrderedIds);

                // Send updated POI list to backend
                const payloadPois = associatedPoiOrderedIds.map((id, idx) => ({
                    poi_id: id,
                    order_in_route: idx + 1
                }));

                console.log('Sending updated POI payload:', payloadPois);

                const response = await fetch(`${apiBase}/admin/routes/${getRouteId(currentRoute)}/pois`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({
                        csrf_token: csrfToken || '',
                        pois: payloadPois
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('POI disassociation response:', result);
                    showNotification('POI başarıyla kaldırıldı', 'success');

                    // Reload POI lists to reflect changes
                    await loadPOIsForAssociation(getRouteId(currentRoute));

                    // Update route visualization on map
                    await showSelectedRouteOnMap(currentRoute);
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('POI disassociation failed:', response.status, errorData);
                    throw new Error(errorData.error || 'POI kaldırılamadı');
                }
            } catch (error) {
                console.error('POI disassociation error:', error);
                showNotification('POI kaldırılırken hata oluştu: ' + error.message, 'error');

                // Revert local changes on error
                const idInt = parseInt(poiId);
                if (!associatedPoiIdSet.has(idInt)) {
                    associatedPoiOrderedIds.push(idInt);
                    associatedPoiIdSet.add(idInt);
                }
            }
        }



        // Reorder associated POI
        async function reorderAssociatedPOI(poiId, delta) {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'warning');
                return;
            }

            console.log('Reordering POI:', poiId, 'delta:', delta);

            const idInt = parseInt(poiId);
            const ids = associatedPoiOrderedIds.slice();
            const idx = ids.indexOf(idInt);

            if (idx < 0) {
                console.warn('POI not found in ordered list:', poiId);
                return;
            }

            const swapIdx = idx + delta;
            if (swapIdx < 0 || swapIdx >= ids.length) {
                console.warn('Invalid swap index:', swapIdx);
                return;
            }

            // Swap positions
            [ids[idx], ids[swapIdx]] = [ids[swapIdx], ids[idx]];

            // Update global state
            associatedPoiOrderedIds = ids;
            associatedPoiIdSet = new Set(ids);

            console.log('New POI order:', associatedPoiOrderedIds);

            try {
                // Persist new order to backend
                const headers = { 'Content-Type': 'application/json' };
                if (csrfToken) headers['X-CSRFToken'] = csrfToken;

                const payloadPois = ids.map((id, i) => ({
                    poi_id: id,
                    order_in_route: i + 1
                }));

                const response = await fetch(`${apiBase}/admin/routes/${getRouteId(currentRoute)}/pois`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({
                        csrf_token: csrfToken || '',
                        pois: payloadPois
                    })
                });

                if (response.ok) {
                    showNotification('POI sıralaması güncellendi', 'success');

                    // Reload POI lists to show new order
                    await loadPOIsForAssociation(getRouteId(currentRoute));

                    // Update route visualization on map
                    await showSelectedRouteOnMap(currentRoute);
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Reorder failed:', response.status, errorData);
                    throw new Error(errorData.error || 'Sıralama kaydedilemedi');
                }
            } catch (error) {
                console.error('POI reorder error:', error);
                showNotification('Sıralama hatası: ' + error.message, 'error');

                // Revert local changes on error
                const originalIdx = ids.indexOf(idInt);
                if (originalIdx >= 0) {
                    [ids[originalIdx], ids[swapIdx]] = [ids[swapIdx], ids[originalIdx]];
                    associatedPoiOrderedIds = ids;
                    associatedPoiIdSet = new Set(ids);
                }
            }
        }

        // Build and save route from associated POIs (geometry + stats)
        async function buildAndSaveRouteFromAssociatedPOIs() {
            if (!currentRoute) return;
            const ids = Array.from(associatedPoiIdSet);
            if (ids.length < 2) { showNotification('Rota için en az 2 POI seçin', 'warning'); return; }
            try {
                // Build ordered waypoint list
                const ordered = ids
                    .map(id => (allPoisForAssociation || []).find(p => getPoiId(p) === id))
                    .filter(Boolean);
                const waypoints = ordered.map((p, i) => ({
                    lat: p.latitude || p.lat,
                    lng: p.longitude || p.lng,
                    name: p.name,
                    order: i + 1
                }));

                let segments = [];
                let totalMeters = 0;
                let estimatedSeconds = 0;

                try {
                    // Request smart route so we follow the actual road network
                    const smartResp = await fetch('/api/route/smart', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ waypoints })
                    });

                    if (!smartResp.ok) throw new Error('smart route failed');
                    const routeData = await smartResp.json();

                    // Extract segments and stats from smart route response
                    const segs = routeData?.route?.segments || [];
                    segments = segs.map(seg => ({ coordinates: seg.coordinates || seg }));
                    totalMeters = Math.round((routeData.route?.total_distance || routeData.total_distance || 0) * 1000);
                    estimatedSeconds = Math.round((routeData.route?.estimated_time || routeData.estimated_time || 0) * 60);
                } catch (smartErr) {
                    console.warn('Smart routing failed, falling back to straight lines:', smartErr);

                    // Fallback: simple straight-line polyline
                    const coords = waypoints.map(wp => ({ lat: wp.lat, lng: wp.lng }));
                    segments = [{ coordinates: coords }];

                    // Haversine distance calculation
                    const R = 6371000;
                    const toRad = d => d * Math.PI / 180;
                    for (let i = 1; i < coords.length; i++) {
                        const a = coords[i - 1], b = coords[i];
                        const dLat = toRad(b.lat - a.lat);
                        const dLon = toRad(b.lng - a.lng);
                        const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
                        const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
                        totalMeters += 2 * R * Math.asin(Math.sqrt(h));
                    }
                    estimatedSeconds = Math.round(totalMeters / 1.2); // ~1.2 m/s walking speed
                }

                // Save geometry to backend
                const headers = { 'Content-Type': 'application/json' };
                if (csrfToken) headers['X-CSRFToken'] = csrfToken;
                const resp = await fetch(`${apiBase}/admin/routes/${currentRoute.id}/geometry`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({
                        geometry: segments,
                        total_distance: totalMeters,
                        estimated_time: estimatedSeconds,
                        waypoints
                    })
                });
                if (!resp.ok) throw new Error('Geometri kaydedilemedi');

                showNotification('Rota geometri kaydedildi', 'success');
                await loadRoutes();
                // Önizleme için vurgula
                await showSelectedRouteOnMap(allRoutes.find(r => getRouteId(r) === getRouteId(currentRoute)) || currentRoute);
            } catch (e) {
                console.error('Build route error:', e);
                showNotification('Rota oluşturma/kaydetme hatası', 'error');
            }
        }

        // Preview on map without saving
        function previewRouteFromAssociatedPOIs() {
            const ids = Array.from(associatedPoiIdSet);
            if (ids.length < 2) { showNotification('Önizleme için en az 2 POI seçin', 'warning'); return; }
            const ordered = ids.map(id => (allPoisForAssociation || []).find(p => getPoiId(p) === id)).filter(Boolean);
            const latlngs = ordered.map(p => [p.latitude || p.lat, p.longitude || p.lng]);
            if (!map) return;
            // Remove old preview if exists
            if (routeLayers['__preview__']) {
                try { map.removeLayer(routeLayers['__preview__']); } catch (e) { }
            }
            const layer = L.polyline(latlngs, { color: '#10b981', weight: 4, opacity: 0.9, dashArray: '6,4' }).addTo(map);
            routeLayers['__preview__'] = layer;
            map.fitBounds(layer.getBounds(), { padding: [30, 30] });
        }

        // Find nearby POIs for route
        async function findNearbyPOIs() {
            console.log('🔍 findNearbyPOIs çağrıldı');
            console.log('currentRoute:', currentRoute);

            if (!currentRoute) {
                console.warn('❌ currentRoute null');
                showNotification('Önce bir rota seçin', 'warning');
                return;
            }

            console.log('✅ currentRoute mevcut, ID:', currentRoute.id);

            try {
                showNotification('Yakın POI\'ler aranıyor...', 'info');

                const response = await fetch(`${apiBase}/routes/${currentRoute.id}/nearby-pois`, {
                    credentials: 'include'
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    const nearbyPois = data.nearby_pois || [];
                    const effectiveMax = (data.parameters && data.parameters.max_distance_meters) ? data.parameters.max_distance_meters : undefined;
                    if (nearbyPois.length > 0) {
                        showNotification(`${nearbyPois.length} yakın POI bulundu ${effectiveMax ? `(${effectiveMax}m)` : ''}`, 'success');
                        displayNearbyPOIsModal(nearbyPois, effectiveMax || '');
                    } else {
                        showNotification('Rota yakınında POI bulunamadı', 'info');
                    }
                } else {
                    throw new Error(data.error || 'Yakın POI\'ler bulunamadı');
                }
            } catch (error) {
                console.error('Nearby POI search error:', error);
                showError('Yakın POI\'ler aranırken hata oluştu: ' + error.message);
            }
        }

        // Auto-associate nearby POIs
        async function autoAssociateNearbyPOIs() {
            console.log('🚀 autoAssociateNearbyPOIs çağrıldı');
            console.log('currentRoute:', currentRoute);

            if (!currentRoute) {
                console.warn('❌ currentRoute null');
                showNotification('Önce bir rota seçin', 'warning');
                return;
            }

            console.log('✅ currentRoute mevcut, ID:', currentRoute.id);

            try {
                showNotification('Yakın POI\'ler otomatik ekleniyor...', 'info');

                const requestData = {
                    auto_confirm: true
                };

                const response = await fetch(`${apiBase}/routes/${currentRoute.id}/auto-associate-pois`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify(requestData)
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    const associatedCount = data.associated_count || 0;
                    if (associatedCount > 0) {
                        showNotification(`${associatedCount} POI otomatik olarak rotaya eklendi`, 'success');
                        // Refresh POI lists
                        await loadPOIsForAssociation(currentRoute.id);
                        // Refresh route display
                        await loadAndDisplayRoutePOIs(currentRoute.id);
                    } else {
                        showNotification('Eklenecek yakın POI bulunamadı', 'info');
                    }
                } else {
                    throw new Error(data.error || 'Otomatik POI ekleme başarısız');
                }
            } catch (error) {
                console.error('Auto-associate POI error:', error);
                showError('Otomatik POI ekleme hatası: ' + error.message);
            }
        }

        // Display nearby POIs in a modal
        function displayNearbyPOIsModal(nearbyPois, maxDistance) {
            const modalHtml = `
                <div class="modal fade" id="nearbyPoisModal" tabindex="-1">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">
                                    <i class="fas fa-map-marker-alt me-2"></i>
                                    Yakın POI'ler (${maxDistance}m içinde)
                                </h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <div class="row">
                                    ${nearbyPois.map(poi => `
                                        <div class="col-md-6 mb-3">
                                            <div class="card h-100">
                                                <div class="card-body">
                                                    <h6 class="card-title">
                                                        <i class="fas fa-map-pin me-1"></i>
                                                        ${poi.name}
                                                    </h6>
                                                    <p class="card-text small text-muted mb-2">
                                                        ${poi.description || 'Açıklama yok'}
                                                    </p>
                                                    <div class="d-flex justify-content-between align-items-center">
                                                        <span class="badge bg-primary">${poi.category}</span>
                                                        <span class="text-muted small">
                                                            ${Math.round(poi.distance_meters)}m
                                                        </span>
                                                    </div>
                                                </div>
                                                <div class="card-footer">
                                                    <button class="btn btn-success btn-sm w-100" 
                                                            onclick="associatePOI(${poi.id}); bootstrap.Modal.getInstance(document.getElementById('nearbyPoisModal')).hide();">
                                                        <i class="fas fa-plus me-1"></i>
                                                        Rotaya Ekle
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Kapat</button>
                                <button type="button" class="btn btn-success" onclick="addAllNearbyPOIs([${nearbyPois.map(p => p.id).join(',')}])">
                                    <i class="fas fa-plus-circle me-1"></i>
                                    Tümünü Ekle
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Remove existing modal if any
            const existingModal = document.getElementById('nearbyPoisModal');
            if (existingModal) {
                existingModal.remove();
            }

            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('nearbyPoisModal'));
            modal.show();
        }

        // Add all nearby POIs to route
        async function addAllNearbyPOIs(poiIds) {
            if (!currentRoute || !poiIds.length) return;

            try {
                showNotification(`${poiIds.length} POI rotaya ekleniyor...`, 'info');

                let addedCount = 0;
                for (const poiId of poiIds) {
                    try {
                        await associatePOI(poiId);
                        addedCount++;
                    } catch (error) {
                        console.warn(`POI ${poiId} eklenemedi:`, error);
                    }
                }

                if (addedCount > 0) {
                    showNotification(`${addedCount} POI başarıyla eklendi`, 'success');
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('nearbyPoisModal'));
                    if (modal) modal.hide();
                } else {
                    showNotification('Hiçbir POI eklenemedi', 'warning');
                }

            } catch (error) {
                console.error('Bulk POI add error:', error);
                showError('POI\'ler eklenirken hata oluştu');
            }
        }

        // Refresh route media
        async function refreshRouteMedia() {
            if (!currentRoute) {
                showNotification('Önce bir rota seçin', 'warning');
                return;
            }

            const routeId = getRouteId(currentRoute);
            console.log('Refreshing media for route:', routeId);
            
            // Show loading state
            const container = document.getElementById('routeCurrentMedia');
            if (container) {
                container.innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Medya dosyaları yenileniyor...</p></div>';
            }

            try {
                await loadRouteMediaForEdit(routeId);
                showNotification('Medya listesi yenilendi', 'success');
            } catch (error) {
                console.error('Error refreshing media:', error);
                showNotification('Medya yenilenirken hata oluştu', 'error');
            }
        }
        // Test function for debugging
        function testNearbyFeature() {
            console.log('🧪 TEST: Yakın POI özelliği test ediliyor');
            console.log('currentRoute:', currentRoute);
            console.log('apiBase:', apiBase);

            if (!currentRoute) {
                alert('❌ currentRoute null! Önce bir rota seçin.');
                return;
            }

            alert(`✅ Test başarılı!\nSeçili rota: ${currentRoute.name}\nID: ${currentRoute.id}\nAPI Base: ${apiBase}`);

            // Test API call
            fetch(`${apiBase}/routes/${currentRoute.id}/nearby-pois`, {
                credentials: 'include'
            })
                .then(response => response.json())
                .then(data => {
                    console.log('🔍 API Test Sonucu:', data);
                    if (data.success) {
                        const eff = data.parameters && data.parameters.max_distance_meters ? ` (radar: ${data.parameters.max_distance_meters}m)` : '';
                        alert(`🎉 API Test Başarılı!\n${data.total_found} POI bulundu${eff}.`);
                    } else {
                        alert(`❌ API Test Başarısız!\nHata: ${data.error}`);
                    }
                })
                .catch(error => {
                    console.error('API Test Hatası:', error);
                    alert(`❌ API Test Hatası!\n${error.message}`);
                });
        }

        // Test media loading function
        async function testMediaLoading() {
            if (!currentRoute) {
                alert('❌ currentRoute null! Önce bir rota seçin.');
                return;
            }

            const routeId = getRouteId(currentRoute);
            console.log('🧪 TEST: Media loading test for route:', routeId);

            // First, check if we're in edit mode
            const isEditMode = document.getElementById('routeEditForm') !== null;
            console.log('Is in edit mode:', isEditMode);

            if (!isEditMode) {
                alert('❌ Rota düzenleme modunda değilsiniz! Önce rotayı düzenlemeye girin.');
                return;
            }

            try {
                const response = await fetch(`${apiBase}/admin/routes/${routeId}/media`, {
                    credentials: 'include'
                });

                console.log('Media API response:', {
                    status: response.status,
                    statusText: response.statusText,
                    headers: Object.fromEntries(response.headers.entries())
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Media API data:', data);
                    
                    // Test the display function
                    const container = document.getElementById('routeCurrentMedia');
                    if (container) {
                        console.log('Media container found:', container);
                        console.log('Container HTML before:', container.innerHTML);
                        displayRouteCurrentMedia(data.media || data || [], routeId);
                        console.log('Container HTML after:', container.innerHTML);
                    } else {
                        console.error('Media container not found');
                        // Try to find the container in different ways
                        const allContainers = document.querySelectorAll('[id*="media"]');
                        console.log('All media-related containers:', allContainers);
                    }
                    
                    alert(`🎉 Media Test Başarılı!\nResponse: ${JSON.stringify(data, null, 2)}`);
                } else {
                    const errorText = await response.text();
                    console.error('Media API error:', errorText);
                    alert(`❌ Media API Error: ${response.status}\n${errorText}`);
                }
            } catch (error) {
                console.error('Media Test Error:', error);
                alert(`❌ Media Test Error:\n${error.message}`);
            }
        }
        // Save route changes (with CSRF)
        async function saveRouteChanges() {
            if (!currentRoute) return;

            try {
                const formData = {
                    name: document.getElementById('editRouteName').value,
                    description: document.getElementById('editRouteDescription').value,
                    route_type: document.getElementById('editRouteType').value,
                    difficulty_level: parseInt(document.getElementById('editDifficulty').value),
                    estimated_duration: parseInt(document.getElementById('editDuration').value) || null,
                    total_distance: parseFloat(document.getElementById('editDistance').value) || null,
                    elevation_gain: parseInt(document.getElementById('editElevation').value) || null,
                    tags: document.getElementById('editTags').value,
                    is_circular: document.getElementById('editIsCircular').checked
                };

                // Add coordinates if they exist
                if (routeCoordinates && routeCoordinates.length > 0) {
                    formData.coordinates = routeCoordinates.map(coord => [coord.lng, coord.lat]);
                }

                const headers = { 'Content-Type': 'application/json' };
                if (csrfToken) headers['X-CSRFToken'] = csrfToken;
                const response = await fetch(`${apiBase}/admin/routes/${currentRoute.id}`, {
                    method: 'PUT',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify(formData)
                });

                if (response.ok) {
                    showNotification('Rota başarıyla güncellendi', 'success');

                    // Update current route data
                    Object.assign(currentRoute, formData);

                    // Refresh routes list
                    await loadRoutes();

                    // Return to detail view
                    displayRouteDetails(currentRoute);
                } else {
                    let message = 'Rota güncellenemedi';
                    try { const errorData = await response.json(); if (errorData?.error) message = errorData.error; } catch (e) { }
                    throw new Error(message);
                }
            } catch (error) {
                console.error('Route update error:', error);
                showError('Rota güncellenirken hata oluştu: ' + error.message);
            }
        }

        // Cancel route edit
        function cancelRouteEdit() {
            if (currentRoute) {
                displayRouteDetails(currentRoute);
            }
        }

        // Export functions
        async function exportRouteAsGPX(routeId) {
            try {
                const response = await fetch(`${apiBase}/routes/${routeId}/export/gpx`);
                if (response.ok) {
                    const blob = await response.blob();
                    downloadFile(blob, `route_${routeId}.gpx`, 'application/gpx+xml');
                } else {
                    throw new Error('GPX export failed');
                }
            } catch (error) {
                console.error('GPX export error:', error);
                showError('GPX dışa aktarımında hata oluştu');
            }
        }

        async function exportRouteAsKML(routeId) {
            try {
                const response = await fetch(`${apiBase}/routes/${routeId}/export/kml`);
                if (response.ok) {
                    const blob = await response.blob();
                    downloadFile(blob, `route_${routeId}.kml`, 'application/vnd.google-earth.kml+xml');
                } else {
                    throw new Error('KML export failed');
                }
            } catch (error) {
                console.error('KML export error:', error);
                showError('KML dışa aktarımında hata oluştu');
            }
        }

        async function exportRouteAsJSON(routeId) {
            try {
                const response = await fetch(`${apiBase}/routes/${routeId}/export/json`);
                if (response.ok) {
                    const blob = await response.blob();
                    downloadFile(blob, `route_${routeId}.json`, 'application/json');
                } else {
                    throw new Error('JSON export failed');
                }
            } catch (error) {
                console.error('JSON export error:', error);
                showError('JSON dışa aktarımında hata oluştu');
            }
        }
        function printRouteDetails(routeId) {
            const route = allRoutes.find(r => r.id === routeId);
            if (!route) return;

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <html>
                <head>
                    <title>${escapeHtml(route.name)} - Rota Detayları</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1 { color: #2563eb; }
                        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 20px 0; }
                        .stat { padding: 10px; background: #f8fafc; border-radius: 8px; }
                        .stat-label { font-weight: bold; }
                    </style>
                </head>
                <body>
                    <h1>${escapeHtml(route.name)}</h1>
                    <p><strong>Tür:</strong> ${ROUTE_TYPES[route.route_type]?.name || route.route_type}</p>
                    <p><strong>Açıklama:</strong> ${escapeHtml(route.description || 'Açıklama bulunmuyor')}</p>
                    
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-label">Süre</div>
                            <div>${route.estimated_duration || 0} dakika</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Mesafe</div>
                            <div>${(route.total_distance || 0).toFixed(2)} km</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Yükselti</div>
                            <div>${route.elevation_gain || 0} m</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Zorluk</div>
                            <div>${getDifficultyStars(route.difficulty_level)} (${route.difficulty_level}/5)</div>
                        </div>
                    </div>
                    
                    ${route.tags ? `<p><strong>Etiketler:</strong> ${escapeHtml(route.tags)}</p>` : ''}
                    <p><strong>Dairesel Rota:</strong> ${route.is_circular ? 'Evet' : 'Hayır'}</p>
                    <p><strong>Oluşturulma:</strong> ${formatDate(route.created_at)}</p>
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        // Utility function to download files
        function downloadFile(blob, filename, mimeType) {
            const url = window.URL.createObjectURL(new Blob([blob], { type: mimeType }));
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        }

        function duplicateCurrentRoute() {
            if (currentRoute) {
                // TODO: Implement route duplication
                showNotification(`${currentRoute.name} rotası kopyalama özelliği yakında eklenecek`, 'info');
            }
        }

        function exportCurrentRoute() {
            if (currentRoute) {
                // TODO: Implement route export
                showNotification(`${currentRoute.name} rotası dışa aktarma özelliği yakında eklenecek`, 'info');
            }
        }

        async function deleteCurrentRoute() {
            if (!currentRoute) return;

            const routeId = getRouteId(currentRoute);
            const routeName = currentRoute.name;

            if (confirm(`"${routeName}" rotasını silmek istediğinizden emin misiniz?\n\nBu işlem geri alınamaz!`)) {
                try {
                    showNotification('Rota siliniyor...', 'info');

                    const response = await fetch(`${apiBase}/admin/routes/${routeId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': csrfToken
                        },
                        credentials: 'include',
                        body: JSON.stringify({
                            csrf_token: csrfToken
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            showNotification(`"${routeName}" rotası başarıyla silindi`, 'success');

                            // Remove from UI
                            allRoutes = allRoutes.filter(r => getRouteId(r) !== routeId);
                            filteredRoutes = filteredRoutes.filter(r => getRouteId(r) !== routeId);

                            // Remove from map
                            if (routeLayers[routeId]) {
                                map.removeLayer(routeLayers[routeId]);
                                delete routeLayers[routeId];
                            }

                            // Clear selection
                            clearSelection();

                            // Update UI
                            displayRoutes();
                            updateBulkActions();

                        } else {
                            showNotification(`Rota silinemedi: ${data.error}`, 'error');
                        }
                    } else if (response.status === 404) {
                        // Route already deleted
                        showNotification(`"${routeName}" rotası zaten silinmiş`, 'warning');

                        // Remove from UI anyway
                        allRoutes = allRoutes.filter(r => getRouteId(r) !== routeId);
                        filteredRoutes = filteredRoutes.filter(r => getRouteId(r) !== routeId);

                        // Remove from map
                        if (routeLayers[routeId]) {
                            map.removeLayer(routeLayers[routeId]);
                            delete routeLayers[routeId];
                        }

                        // Clear selection
                        clearSelection();

                        // Update UI
                        displayRoutes();
                        updateBulkActions();
                    } else {
                        showNotification(`HTTP hatası: ${response.status}`, 'error');
                    }
                } catch (error) {
                    console.error('Error deleting route:', error);
                    showNotification('Rota silinirken hata oluştu', 'error');
                }
            }
        }

        function exportSelected() {
            if (selectedRoutes.size > 0) {
                // TODO: Implement bulk export
                showNotification(`${selectedRoutes.size} rota dışa aktarma özelliği yakında eklenecek`, 'info');
            }
        }

        function bulkEdit() {
            if (selectedRoutes.size > 0) {
                // TODO: Implement bulk edit
                showNotification(`${selectedRoutes.size} rota toplu düzenleme özelliği yakında eklenecek`, 'info');
            }
        }

        function deleteSelected() {
            if (selectedRoutes.size > 0) {
                if (confirm(`${selectedRoutes.size} rotayı silmek istediğinizden emin misiniz?\n\nBu işlem geri alınamaz!`)) {
                    deleteSelectedRoutes();
                }
            }
        }

        async function deleteSelectedRoutes() {
            const routeIds = Array.from(selectedRoutes);
            let successCount = 0;
            let errorCount = 0;

            showNotification(`${routeIds.length} rota siliniyor...`, 'info');

            for (const routeId of routeIds) {
                try {
                    const response = await fetch(`${apiBase}/admin/routes/${routeId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': csrfToken
                        },
                        credentials: 'include',
                        body: JSON.stringify({
                            csrf_token: csrfToken
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.message && !data.error) {
                            // Success response has 'message' field
                            successCount++;

                            // Remove from UI
                            allRoutes = allRoutes.filter(r => getRouteId(r) !== routeId);
                            filteredRoutes = filteredRoutes.filter(r => getRouteId(r) !== routeId);

                            // Remove from map
                            if (routeLayers[routeId]) {
                                map.removeLayer(routeLayers[routeId]);
                                delete routeLayers[routeId];
                            }

                            // Clear selection if this route was selected
                            if (currentRoute && getRouteId(currentRoute) === routeId) {
                                clearSelection();
                            }
                        } else {
                            errorCount++;
                            console.error(`Failed to delete route ${routeId}:`, data.error || 'Unknown error');
                        }
                    } else if (response.status === 404) {
                        // Route already deleted, treat as success
                        successCount++;
                        console.warn(`Route ${routeId} already deleted (404)`);

                        // Remove from UI anyway
                        allRoutes = allRoutes.filter(r => getRouteId(r) !== routeId);
                        filteredRoutes = filteredRoutes.filter(r => getRouteId(r) !== routeId);

                        // Remove from map
                        if (routeLayers[routeId]) {
                            map.removeLayer(routeLayers[routeId]);
                            delete routeLayers[routeId];
                        }

                        // Clear selection if this route was selected
                        if (currentRoute && getRouteId(currentRoute) === routeId) {
                            clearSelection();
                        }
                    } else {
                        errorCount++;
                        console.error(`HTTP error deleting route ${routeId}:`, response.status);
                    }
                } catch (error) {
                    errorCount++;
                    console.error(`Error deleting route ${routeId}:`, error);
                }
            }

            // Clear selection
            selectedRoutes.clear();

            // Update UI
            displayRoutes();
            updateBulkActions();

            // Show result notification
            if (successCount > 0 && errorCount === 0) {
                showNotification(`${successCount} rota başarıyla silindi`, 'success');
            } else if (successCount > 0 && errorCount > 0) {
                showNotification(`${successCount} rota silindi, ${errorCount} rota silinemedi`, 'warning');
            } else {
                showNotification(`Rotalar silinemedi`, 'error');
            }
        }

        function toggleMapLayer(layerType) {
            // TODO: Implement map layer switching
            showNotification(`${layerType} katmanı özelliği yakında eklenecek`, 'info');
        }

    function fitMapToRoutes() {
        if (Object.keys(routeLayers).length > 0) {
            const group = new L.featureGroup(Object.values(routeLayers));
            map.fitBounds(group.getBounds(), { padding: [20, 20] });
        }
    }
    </script>
    <script src="https://unpkg.com/exifreader/dist/exif-reader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script>
    (() => {
      // UYARILARI BASTIR: Mevcut kodun gösterdiği "EXIF konum..." alert'lerini konsola indir.
      const _alert = window.alert;
      window.alert = function(msg) {
        if (String(msg).includes('EXIF') && String(msg).includes('konum')) {
          console.info('[info]', msg);
          return; // alert gösterme
        }
        return _alert.apply(this, arguments);
      };

      // DMS -> decimal yardımcıları
      const __dmsToDec = (arr, ref) => {
        if (!arr) return null;
        const [d, m, s] = arr;
        let v = Number(d) + Number(m)/60 + Number(s)/3600;
        if (ref === 'S' || ref === 'W') v = -v;
        return v;
      };
      const __parseDMS = (s) => {
        const m = String(s).match(/(-?\d+(?:\.\d+)?)|([NSEW])/gi);
        if (!m) return null;
        const nums = m.filter(x => !/[NSEW]/i.test(x)).map(Number);
        const ref  = (m.find(x => /[NSEW]/i.test(x)) || '').toUpperCase();
        const [D=0,M=0,S=0] = nums;
        let v = D + M/60 + S/3600;
        return (ref==='S' || ref==='W') ? -v : v;
      };

      // Manuel akış giriş noktası: Sayfada hangisi varsa onu kullan.
      function __placeViaManualFlow(lat, lon) {
        // 1) Doğrudan sizin fonksiyonlarınız
        if (typeof window.setLocationFromLatLon === 'function')
          return window.setLocationFromLatLon(lat, lon, { zoom: 16 });
        if (typeof window.addManualLocation === 'function')
          return window.addManualLocation(lat, lon);

        // 2) Manuel buton varsa tetiklemeden önce form alanlarını doldur
        const latInput = document.getElementById('lat') || document.querySelector('[name="lat"]');
        const lonInput = document.getElementById('lon') || document.getElementById('lng') || document.querySelector('[name="lon"],[name="lng"]');
        if (latInput) latInput.value = lat;
        if (lonInput) lonInput.value = lon;

        const manualBtn = document.querySelector('#btn-manual-location, #manual-location-btn, button[data-action="manual-location"]');
        if (manualBtn) manualBtn.click();

        // 3) Son çare Leaflet: global harita değişkenini sez ve marker koy
        const map = window.routeMap || window.map || window.leafletMap;
        if (map && typeof L !== 'undefined') {
          if (!window.__photoMarker) window.__photoMarker = L.marker([lat, lon], { draggable: true }).addTo(map);
          else window.__photoMarker.setLatLng([lat, lon]);
          try { map.setView([lat, lon], 16); } catch(e) {}
        }
      }

      async function __readGpsFromFile(file) {
        // 1) ExifReader (JPEG/HEIC/WEBP dahil; XMP de dahil)
        try {
          const tags = await ExifReader.load(file, { expanded: true, includeXmp: true });
          let lat = tags?.gps?.Latitude ?? tags?.exif?.GPSLatitude?.value ?? tags?.xmp?.exif?.GPSLatitude?.value;
          let lon = tags?.gps?.Longitude ?? tags?.exif?.GPSLongitude?.value ?? tags?.xmp?.exif?.GPSLongitude?.value;
          if (typeof lat === 'string') lat = __parseDMS(lat);
          if (typeof lon === 'string') lon = __parseDMS(lon);
          if (typeof lat === 'number' && typeof lon === 'number') return { lat, lon };
        } catch (e) { /* sessiz geç */ }

        // 2) exif-js fallback (JPEG/TIFF)
        if (window.EXIF) {
          return await new Promise((resolve) => {
            EXIF.getData(file, function() {
              const lat = __dmsToDec(EXIF.getTag(this, 'GPSLatitude'),  EXIF.getTag(this, 'GPSLatitudeRef'));
              const lon = __dmsToDec(EXIF.getTag(this, 'GPSLongitude'), EXIF.getTag(this, 'GPSLongitudeRef'));
              resolve({ lat, lon });
            });
          });
        }

        return { lat: null, lon: null };
      }

      // TÜM file input'larını en erken aşamada yakala (canvas/preview'den önce)
      document.addEventListener('change', async (e) => {
        const el = e.target;
        if (!(el && el.matches && el.matches('input[type="file"]'))) return;

        const file = el.files && el.files[0];
        if (!file) return;

        const { lat, lon } = await __readGpsFromFile(file);

        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          __placeViaManualFlow(lat, lon); // Manuel akışla aynı sonuç
          console.info('[gps] Foto EXIF GPS bulundu:', lat, lon);
        } else {
          console.info('[gps] EXIF GPS bulunamadı (dosyada yok ya da EXIF kilitli). Manuel akış devam.');
        }
      }, { capture: true, passive: true });
    })();
    </script>
</body>

</html>